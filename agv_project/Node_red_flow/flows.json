[
    {
        "id": "49f8711fc297a8c1",
        "type": "tab",
        "label": "í”Œë¡œìš° 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "048a808c4f50c1eb",
        "type": "telegram receiver",
        "z": "49f8711fc297a8c1",
        "name": "",
        "bot": "d10c4415b361b866",
        "saveDataDir": "",
        "filterCommands": false,
        "hasinput": false,
        "inputs": 0,
        "handleallupdates": false,
        "x": 350,
        "y": 480,
        "wires": [
            [
                "7476d3bed8965c26"
            ],
            []
        ]
    },
    {
        "id": "d1e13ead5e796c2d",
        "type": "telegram sender",
        "z": "49f8711fc297a8c1",
        "name": "",
        "bot": "d10c4415b361b866",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1170,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "7476d3bed8965c26",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "function 1",
        "func": "function pad(n, w = 2) { return String(n).padStart(w, '0'); }\n\n// KST ê¸°ì¤€: YYYYMMDD_HHMMSS_mmm\nfunction tsKST() {\n  const k = new Date(Date.now() + 9 * 60 * 60 * 1000); // UTC+9\n  const y = k.getUTCFullYear();\n  const mo = pad(k.getUTCMonth() + 1);\n  const d = pad(k.getUTCDate());\n  const hh = pad(k.getUTCHours());\n  const mm = pad(k.getUTCMinutes());\n  const ss = pad(k.getUTCSeconds());\n  const ms = pad(k.getUTCMilliseconds(), 3);\n  return `${y}${mo}${d}_${hh}${mm}${ss}_${ms}`;\n}\n\nfunction makeInteractionId(chatId, mode) {\n  const ts = tsKST();\n  const safeMode = (mode || \"text\").toLowerCase();\n  return `it_${ts}_tg_${chatId}_${safeMode}`;\n}\n\nfunction makeMqtt(chatId, text, interactionId, topic, type, target_area, inputKind) {\n  return {\n    topic,\n    payload: JSON.stringify({\n      type,\n      target_area,\n      user_id: `tg_${chatId}`,\n      meta: { source: \"telegram\", input: inputKind, raw: text, interaction_id: interactionId }\n    })\n  };\n}\n\nfunction makeFsMsg(interactionObj) {\n  // task_idëŠ” null ë®ì–´ì“°ê¸° ë°©ì§€(ì•„ì˜ˆ ì œê±°)\n  const copy = { ...interactionObj };\n  if (\"task_id\" in copy) delete copy.task_id;\n  return { payload: copy };\n}\n\nfunction makeInteractionBase(chatId, interactionId, inputMode, rawInput) {\n  return {\n    ts: Date.now(),\n    interaction_id: interactionId,\n    source: \"telegram\",\n    user_id: `tg_${chatId}`,\n    input_mode: inputMode,\n    raw_input: rawInput,\n    parsed: null,\n    result: \"pending\",\n    error: null\n  };\n}\n\n// -------------------- ì…ë ¥ ì¶”ì¶œ --------------------\nconst chatId = msg.payload?.chatId;\nconst text = (msg.payload?.content || \"\").trim();\n\n// WebApp URL\nconst WEBAPP_URL = global.get(\"WEBAPP_URL\") || \"https://supervisor-trigger-angeles-romance.trycloudflare.com/user\";\n\n// ë²„íŠ¼ ëª©ë¡(ì •í™•íˆ ë§¤ì¹­)\nconst BUTTONS = new Set([\n  \"â˜• ë¬¼ ê°€ì ¸ì™€ì¤˜\",\n  \"ğŸ¥¤ ì»µ ê°€ì ¸ê°€ì¤˜\",\n  \"ğŸ§¹ í™˜ê²½ ì •ë¦¬í•´ì¤˜\",\n  \"ğŸ“ ì§€ê¸ˆ ìƒíƒœ ì•Œë ¤ì¤˜\",\n  \"ğŸ“Š ë¦¬í¬íŠ¸ & ëŒ€ì‹œë³´ë“œ ì—´ê¸°\"\n]);\n\n// -------------------- 0) voice (ê°€ì¥ ë¨¼ì € return) --------------------\nif (msg.payload?.type === \"voice\" && msg.payload?.weblink) {\n  const interactionId = makeInteractionId(chatId, \"voice\");\n  msg._interactionId = interactionId;\n\n  const weblink = msg.payload.weblink;\n  const fileId = msg.payload.content;\n\n  const interaction = makeInteractionBase(chatId, interactionId, \"voice\", fileId);\n  interaction.meta = { weblink };\n\n  const tgMsg = {\n    ...msg,\n    payload: { chatId, type: \"message\", content: \"ğŸ™ï¸ ìŒì„± ì¸ì‹ ì¤‘ì´ì—ìš”â€¦\", options: {} }\n  };\n\n  const sttMsg = {\n    _tg: { chatId },\n    _interactionId: interactionId,\n    weblink\n  };\n\n  // out1: tg, out4: fs, out5: stt\n  return [tgMsg, null, null, makeFsMsg(interaction), sttMsg];\n}\n\n// -------------------- 1) ë¹ˆ ì…ë ¥ --------------------\nif (!text) {\n  const interactionId = makeInteractionId(chatId, \"text\");\n  msg._interactionId = interactionId;\n\n  const interaction = makeInteractionBase(chatId, interactionId, \"text\", text);\n  interaction.result = \"rejected\";\n  interaction.error = { stage: \"input\", message: \"empty text\" };\n\n  msg.payload = {\n    chatId, type: \"message\",\n    content: \"ë‚´ìš©ì´ ë¹„ì–´ ìˆì–´ìš” ğŸ™‚\\nì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì„œ ìš”ì²­í•´ ì£¼ì„¸ìš”.\",\n    options: {}\n  };\n  return [msg, null, null, makeFsMsg(interaction)];\n}\n\n// -------------------- 2) /start --------------------\nif (text === \"/start\") {\n  const interactionId = makeInteractionId(chatId, \"command\");\n  msg._interactionId = interactionId;\n\n  if (!flow.get(\"default_area_\" + chatId)) flow.set(\"default_area_\" + chatId, \"USER1\");\n\n  const interaction = makeInteractionBase(chatId, interactionId, \"command\", text);\n  interaction.result = \"accepted\";\n\n  msg.payload = {\n    chatId,\n    type: \"message\",\n    content: \"ì•ˆë…•í•˜ì„¸ìš”! AGV ì„œë¹„ìŠ¤ ë´‡ í˜„ì„±ì´ì…ë‹ˆë‹¤.\\në¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?\",\n    options: {\n      reply_markup: {\n        keyboard: [\n          [\"â˜• ë¬¼ ê°€ì ¸ì™€ì¤˜\", \"ğŸ¥¤ ì»µ ê°€ì ¸ê°€ì¤˜\"],\n          [\"ğŸ§¹ í™˜ê²½ ì •ë¦¬í•´ì¤˜\"],\n          [\"ğŸ“ ì§€ê¸ˆ ìƒíƒœ ì•Œë ¤ì¤˜\", \"ğŸ“Š ë¦¬í¬íŠ¸ & ëŒ€ì‹œë³´ë“œ ì—´ê¸°\"]\n        ],\n        resize_keyboard: true,\n        one_time_keyboard: false\n      }\n    }\n  };\n\n  return [msg, null, null, makeFsMsg(interaction)];\n}\n\n// -------------------- 3) button --------------------\nif (BUTTONS.has(text)) {\n  const interactionId = makeInteractionId(chatId, \"button\");\n  msg._interactionId = interactionId;\n\n  const interaction = makeInteractionBase(chatId, interactionId, \"button\", text);\n\n  // ê¸°ë³¸ íƒ€ê²Ÿ(ì§€ê¸ˆì€ USER1 ê³ ì •, ë‚˜ì¤‘ì— default_areaë¡œ ë°”ê¿”ë„ ë¨)\n  const area = \"USER1\";\n\n  // ë²„íŠ¼ë³„ ì²˜ë¦¬\n  if (text === \"â˜• ë¬¼ ê°€ì ¸ì™€ì¤˜\") {\n    interaction.parsed = { type: \"deliver_water\", target_area: area, confidence: 1.0 };\n    interaction.result = \"accepted\";\n\n    const mqttMsg = makeMqtt(chatId, text, interactionId, \"cmd/water/request\", \"deliver_water\", area, \"button\");\n\n    msg.payload = {\n      chatId, type: \"message\",\n      content: \"ë¬¼ ë°°ë‹¬ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš” ğŸ’§\\nê¸ˆë°© ê°–ë‹¤ë“œë¦´ê²Œìš”!\",\n      options: {}\n    };\n\n    return [msg, mqttMsg, null, makeFsMsg(interaction)];\n  }\n\n  if (text === \"ğŸ¥¤ ì»µ ê°€ì ¸ê°€ì¤˜\") {\n    interaction.parsed = { type: \"collect_cup\", target_area: area, confidence: 1.0 };\n    interaction.result = \"accepted\";\n\n    const mqttMsg = makeMqtt(chatId, text, interactionId, \"cmd/cup/request\", \"collect_cup\", area, \"button\");\n\n    msg.payload = {\n      chatId, type: \"message\",\n      content: \"ì»µ íšŒìˆ˜ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš” ğŸ¥¤\\në°”ë¡œ ì²˜ë¦¬í• ê²Œìš”!\",\n      options: {}\n    };\n\n    return [msg, mqttMsg, null, makeFsMsg(interaction)];\n  }\n\n  if (text === \"ğŸ§¹ í™˜ê²½ ì •ë¦¬í•´ì¤˜\") {\n    // ë‚´ë¶€ typeì€ ê¸°ì¡´ ìœ ì§€(collect_laundry)\n    interaction.parsed = { type: \"collect_laundry\", target_area: area, confidence: 1.0 };\n    interaction.result = \"accepted\";\n\n    const mqttMsg = makeMqtt(chatId, text, interactionId, \"cmd/laundry/request\", \"collect_laundry\", area, \"button\");\n\n    msg.payload = {\n      chatId, type: \"message\",\n      content: \"í™˜ê²½ ì •ë¦¬ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš” ğŸ§¹\\nì£¼ë³€ì„ ê¹”ë”í•˜ê²Œ ì •ë¦¬í• ê²Œìš”!\",\n      options: {}\n    };\n\n    return [msg, mqttMsg, null, makeFsMsg(interaction)];\n  }\n\n  if (text === \"ğŸ“ ì§€ê¸ˆ ìƒíƒœ ì•Œë ¤ì¤˜\") {\n    interaction.parsed = { type: \"show_status\", target_area: null, confidence: 1.0 };\n    interaction.result = \"accepted\";\n\n    const robots = global.get(\"robots\") || {};\n    const taskQueue = global.get(\"taskQueue\") || [];\n    const r = robots[\"agv1\"];\n\n    if (!r) {\n      msg.payload = {\n        chatId,\n        type: \"message\",\n        content: \"ğŸ“ ì•„ì§ AGV ìƒíƒœë¥¼ ëª» ë°›ì•˜ì–´ìš”.\\n(ë¡œë´‡ status ìˆ˜ì‹  í™•ì¸ í•„ìš”)\",\n        options: {}\n      };\n      return [msg, null, null, makeFsMsg(interaction)];\n    }\n\n    const AREA_LABEL = {\n      BASE: \"ë² ì´ìŠ¤\",\n      DOCK: \"ë„í‚¹\",\n      CHARGE: \"ì¶©ì „ì†Œ\",\n      WATER: \"ì •ìˆ˜ê¸°\",\n      DROP: \"ìˆ˜ê±°í•¨\",\n      RES_A: \"ë£¸1\",\n      RES_B: \"ë£¸2\",\n      RES_C: \"ë£¸3\",\n      // êµ¬ë²„ì „ í˜¸í™˜ìš© (í˜¹ì‹œ ëª°ë¼ ë‚¨ê²¨ë‘ )\n      USER1: \"ë£¸1\",\n      USER2: \"ë£¸2\",\n      USER3: \"ë£¸3\"\n    };\n    const TASK_LABEL = { deliver_water: \"â˜• ë¬¼ ë°°ë‹¬\", collect_cup: \"ğŸ¥¤ ì»µ íšŒìˆ˜\", collect_laundry: \"ğŸ§¹ í™˜ê²½ ì •ë¦¬\" };\n\n    function areaName(a) { return AREA_LABEL[a] || a || \"â€”\"; }\n\n    const state = (r.state || \"unknown\").toLowerCase();\n    const prettyState =\n      (r.error_code) ? \"ì˜¤ë¥˜ â—\" :\n        (state === \"running\") ? \"ì´ë™ ì¤‘ ğŸšš\" :\n          (state === \"idle\") ? \"ëŒ€ê¸° ì¤‘ âœ…\" :\n            (state === \"charging\") ? \"ì¶©ì „ ì¤‘ ğŸ”Œ\" : state;\n\n    // í˜„ì¬ task ì°¾ê¸°: robot.task_id ìš°ì„ \n    let t = null;\n    if (r.task_id) t = taskQueue.find(x => x.task_id === r.task_id) || null;\n    if (!t) t = taskQueue.find(x => x.assigned_robot === \"agv1\" && x.status === \"running\") || null;\n\n    const lines = [];\n    lines.push(`ğŸ“ AGV ìƒíƒœ: ${prettyState}`);\n    if (r.battery != null) lines.push(`ğŸ”‹ ë°°í„°ë¦¬: ${r.battery}%`);\n    if (r.area) lines.push(`ğŸ“Œ ìœ„ì¹˜: ${areaName(r.area)}`);\n    if (r.error_code) lines.push(`âš ï¸ ì›ì¸: ${r.error_code}`);\n\n    if (!t) {\n      lines.push(\"\");\n      lines.push(\"ğŸ§¾ ì§„í–‰ ì¤‘ ì‘ì—…: ì—†ìŒ\");\n    } else {\n      const label = TASK_LABEL[t.type] || t.type || \"ì‘ì—…\";\n      const target = areaName(t.target_area);\n\n      // ë‚¨ì€ì‹œê°„ ê³„ì‚° (ë²„íŠ¼ ëˆ„ë¥¼ ë•Œë§ˆë‹¤ 20â†’15ì²˜ëŸ¼ ê°ì†Œ)\n      const expectedMs = Number(t.expected_duration_ms || 0);\n      const startedAt = Number(t.started_at || t.created_at || 0);\n      let remainSec = null;\n\n      if (expectedMs > 0 && startedAt > 0 && (state === \"running\" || t.status === \"running\")) {\n        const elapsedMs = Date.now() - startedAt;\n        const remainMs = Math.max(0, expectedMs - elapsedMs);\n        remainSec = Math.ceil(remainMs / 1000);\n      } else if (expectedMs > 0) {\n        remainSec = Math.ceil(expectedMs / 1000); // ì•„ì§ running ì „ì´ë©´ \"ì˜ˆìƒ\"ë§Œ í‘œì‹œ\n      }\n\n      lines.push(\"\");\n      lines.push(`ğŸ§¾ ì§„í–‰ ì¤‘ ì‘ì—…: ${label} â†’ ${target}`);\n      if (remainSec != null) lines.push(`â³ ì˜ˆìƒ ë‚¨ì€ ì‹œê°„: ì•½ ${remainSec}ì´ˆ`);\n    }\n\n    msg.payload = {\n      chatId,\n      type: \"message\",\n      content: lines.join(\"\\n\"),\n      options: {}\n    };\n\n    return [msg, null, null, makeFsMsg(interaction)];\n  }\n\n\n  if (text === \"ğŸ“Š ë¦¬í¬íŠ¸ & ëŒ€ì‹œë³´ë“œ ì—´ê¸°\") {\n    interaction.parsed = { type: \"open_dashboard\", target_area: null, confidence: 1.0 };\n    interaction.result = \"accepted\";\n\n    msg.payload = {\n      chatId,\n      type: \"message\",\n      content: \"ğŸ“Š ë¦¬í¬íŠ¸ & ëŒ€ì‹œë³´ë“œë¥¼ ì—´ì–´ë“œë¦´ê²Œìš” ğŸ™‚\",\n      options: {\n        reply_markup: {\n          inline_keyboard: [[\n            { text: \"ì—´ê¸°\", web_app: { url: WEBAPP_URL } }\n          ]]\n        }\n      }\n    };\n\n    return [msg, null, null, makeFsMsg(interaction)];\n  }\n}\n\n// -------------------- 4) ê·¸ ì™¸ = text â†’ LLM --------------------\n{\n  const interactionId = makeInteractionId(chatId, \"text\");\n  msg._interactionId = interactionId;\n\n  const interaction = makeInteractionBase(chatId, interactionId, \"text\", text);\n  interaction.result = \"pending\";\n\n  msg.payload = {\n    chatId,\n    type: \"message\",\n    content: \"ìš”ì²­ì„ í™•ì¸í•˜ê³  ìˆì–´ìš” ğŸ¤–\\nì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.\",\n    options: {}\n  };\n\n  const llmReq = {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${global.get(\"GMS_KEY\")}`\n    },\n    payload: {\n      model: \"gpt-4.1-nano\",\n      temperature: 0.2,\n      max_tokens: 200,\n      messages: [\n        {\n          role: \"system\",\n          content:\n            \"ë„ˆëŠ” AGV ì‚¬ìš©ì ì•±ì˜ ëª…ë ¹ íŒŒì„œë‹¤. ë°˜ë“œì‹œ JSONë§Œ ì¶œë ¥í•´.\\n\" +\n            \"í—ˆìš© type: deliver_water, collect_cup, collect_laundry\\n\" +\n            \"í—ˆìš© target_area: USER1, USER2, DOCK, BASE\\n\" +\n            \"ì‚¬ìš©ì í‘œí˜„ 'í™˜ê²½ ì •ë¦¬/ë°”ë‹¥ ì •ë¦¬/ì •ë¦¬í•´ì¤˜' ëŠ” collect_laundryë¡œ ë§¤í•‘í•´.\\n\" +\n            'í˜•ì‹: {\"type\":\"...\",\"target_area\":\"...\",\"confidence\":0.0}\\n' +\n            \"ì¶”ë¡  ì„¤ëª… ê¸ˆì§€. JSON ì™¸ í…ìŠ¤íŠ¸ ê¸ˆì§€.\"\n        },\n        { role: \"user\", content: text }\n      ]\n    },\n    _tg: { chatId, raw: text },\n    _interactionId: interactionId\n  };\n\n  // out1: tg reply, out3: llm, out4: fs\n  return [msg, null, llmReq, makeFsMsg(interaction)];\n}\n",
        "outputs": 5,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 480,
        "wires": [
            [
                "d1e13ead5e796c2d"
            ],
            [
                "6b5f1a99de2569f0"
            ],
            [
                "54431a46252d1602"
            ],
            [
                "350dfce793e04058"
            ],
            [
                "f65016bb2f2505ba"
            ]
        ]
    },
    {
        "id": "6b5f1a99de2569f0",
        "type": "mqtt out",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3c16a07776b27396",
        "x": 1130,
        "y": 320,
        "wires": []
    },
    {
        "id": "bea82cdd7f9e1fa3",
        "type": "mqtt in",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "cmd/+/request",
        "qos": "2",
        "datatype": "utf8",
        "broker": "3c16a07776b27396",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 1120,
        "wires": [
            [
                "e0253ffdf7c81394",
                "084632d493b02014"
            ]
        ]
    },
    {
        "id": "e0253ffdf7c81394",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "function 2",
        "func": "function pad(n, w = 2) { return String(n).padStart(w, '0'); }\n\n// KST ê¸°ì¤€ í…ìŠ¤íŠ¸ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±\nfunction tsKST() {\n  const k = new Date(Date.now() + 9 * 60 * 60 * 1000); // UTC+9\n  const y = k.getUTCFullYear();\n  const mo = pad(k.getUTCMonth() + 1);\n  const d = pad(k.getUTCDate());\n  const hh = pad(k.getUTCHours());\n  const mm = pad(k.getUTCMinutes());\n  const ss = pad(k.getUTCSeconds());\n  const ms = pad(k.getUTCMilliseconds(), 3);\n  return `${y}${mo}${d}_${hh}${mm}${ss}_${ms}`;\n}\n\nlet data = {};\ntry {\n  data = JSON.parse(msg.payload || '{}');\n} catch (e) {\n  node.error('Invalid JSON payload in cmd request', msg);\n  return null;\n}\n\n// âœ… interaction_id ì¶”ì¶œ\nconst interactionId = data?.meta?.interaction_id || null;\n\n// ê¸€ë¡œë²Œ taskQueue ê°€ì ¸ì˜¤ê¸°\nlet queue = global.get('taskQueue') || [];\n\n// task_id ìƒì„±\nconst ts = tsKST();\n\n// task type ë¨¼ì € ê²°ì • (ëª©ì ì§€ ì„¤ì •ì— í•„ìš”í•¨)\nconst taskType = data.type || (() => {\n  if (msg.topic.startsWith('cmd/water/')) return 'deliver_water';\n  if (msg.topic.startsWith('cmd/cup/')) return 'collect_cup';\n  if (msg.topic.startsWith('cmd/laundry/')) return 'collect_laundry';\n  return 'unknown';\n})();\n\n// ==========================================================\n// [ìˆ˜ì •ëœ ë¶€ë¶„] ì‚¬ìš©ì ìœ„ì¹˜ ì„¤ì • ê°€ì ¸ì˜¤ê¸° ë° ëª©ì ì§€ ì˜¤ë²„ë¼ì´ë“œ\n// ==========================================================\n// 1. ê¸€ë¡œë²Œ ë³€ìˆ˜ì— ì €ì¥ëœ ì•± ì„¤ì • ê°€ì ¸ì˜¤ê¸°\nconst appSettings = global.get('appSettings') || {};\nconst userPlace = appSettings.user_place || 'RES_B'; // ì„¤ì • ì—†ìœ¼ë©´ ê¸°ë³¸ê°’\n\n// 2. ëª©ì ì§€ ê²°ì •\nlet finalTarget = data.target_area;\n\n// 3. ë§Œì•½ 'ì„œë¹„ìŠ¤ ìš”ì²­(ë¬¼, ì»µ, ì •ë¦¬)'ì´ë¼ë©´ -> ë¬´ì¡°ê±´ ì‚¬ìš©ì í˜„ì¬ ì„¤ì • ìœ„ì¹˜ë¡œ ë³€ê²½\nif (['deliver_water', 'collect_cup', 'collect_laundry'].includes(taskType)) {\n  // ì•±ì—ì„œ ì„¤ì •í•œ ìœ„ì¹˜(userPlace)ë¥¼ ì‚¬ìš©\n  finalTarget = userPlace;\n}\n// ==========================================================\n\nconst taskId = interactionId || `task_${ts}`; // interactionIdê°€ ì—†ìœ¼ë©´ fallback\n\nfunction normTargetArea(raw) {\n  const s = String(raw || \"\").toUpperCase();\n\n  const map = {\n    // ì˜› ì´ë¦„ í˜¸í™˜\n    USER1: \"RES_A\",\n    USER2: \"RES_B\",\n    USER3: \"RES_C\",\n    BASE: \"CHARGE\",\n    HOME: \"CHARGE\",\n    DOCK: \"CHARGE\",\n  };\n\n  if (map[s]) return map[s];\n\n  // ì´ë¯¸ ìƒˆ ì´ë¦„ì´ë©´ ê·¸ëŒ€ë¡œ\n  if ([\"CHARGE\", \"WATER\", \"DROP\", \"RES_A\", \"RES_B\", \"RES_C\"].includes(s)) return s;\n\n  // ë””í´íŠ¸\n  return \"RES_B\";\n}\n\n// Task ê°ì²´ ìƒì„±\nconst task = {\n  task_id: taskId,\n  type: taskType,\n  target_area: normTargetArea(finalTarget || \"RES_B\"), // ìˆ˜ì •ëœ finalTarget ì‚¬ìš©\n  user_id: data.user_id || null,\n\n  // âœ… ì—°ê²° í‚¤\n  interaction_id: interactionId,\n\n  status: 'pending',\n  created_at: Date.now(),\n};\n\n// ---- ì˜ˆìƒ ì†Œìš”ì‹œê°„(ms) ----\nconst taskStats = global.get(\"taskStats\") || {};\nconst baseMsMap = { deliver_water: 20000, collect_cup: 15000, collect_laundry: 25000, unknown: 20000 };\n\nconst stat = taskStats[taskType];\nconst expectedMs = (stat && stat.ema_ms) ? Math.round(stat.ema_ms) : (baseMsMap[taskType] || 20000);\n\ntask.expected_duration_ms = expectedMs;\ntask.expected_duration_s = Math.ceil(expectedMs / 1000);\ntask.eta_basis = (stat && stat.ema_ms) ? \"ema\" : \"default\";\n\n// íì— push\nqueue.push(task);\nglobal.set('taskQueue', queue);\n\n// ë””ë²„ê·¸ ë¡œê·¸ (ëª©ì ì§€ê°€ ì–´ë””ë¡œ ì¡í˜”ëŠ”ì§€ í™•ì¸ìš©)\nnode.warn({ action: 'TASK_CREATED', task_type: taskType, target: task.target_area, from_setting: userPlace });\n\n// âœ… Firestore tasks ë¬¸ì„œ ìƒì„±/ì—…ì„œíŠ¸\nconst db = global.get(\"db\");\n\nif (db && taskId) {\n  db.collection(\"tasks\").doc(taskId).set({\n    ...task,\n    expected_duration_ms: Number(task.expected_duration_ms || expectedMs),\n    created_at: task.created_at || Date.now(),\n  }, { merge: true })\n    .catch(err => node.error(\"[tasks create] \" + err));\n}\n\nif (db && interactionId) {\n  db.collection(\"interactions\").doc(interactionId).set({\n    task_id: taskId,\n    linked_at: Date.now()\n  }, { merge: true })\n    .then(() => node.warn(`FS interaction linked: ${interactionId} -> ${taskId}`))\n    .catch(err => node.error(err));\n}\n\n// ì•„ë˜ë¡œ ë„˜ê²¨ì¤„ ë©”ì‹œì§€ ì„¸íŒ…\nmsg.task = task;\nmsg.payload = JSON.stringify(task);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 1120,
        "wires": [
            [
                "2ccacb1608c5ba74"
            ]
        ]
    },
    {
        "id": "8fa070ba704430fc",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "function 3",
        "func": "// // // v0.1: ë“¤ì–´ì˜¨ taskë¥¼ ë¬´ì¡°ê±´ agv1ì— ë°”ë¡œ í• ë‹¹í•´ì„œ ë³´ëƒ„\n\n// // let task = msg.task;\n// // if (!task) {\n// //     node.warn('No task found in msg');\n// //     return null;\n// // }\n\n// // // ìƒíƒœ ë³€ê²½\n// // task.status = 'running';\n// // task.assigned_robot = 'agv1';\n// // task.started_at = Date.now();\n\n// // // ê¸€ë¡œë²Œ íì—ë„ ë°˜ì˜\n// // let queue = global.get('taskQueue') || [];\n// // for (let i = 0; i < queue.length; i++) {\n// //     if (queue[i].task_id === task.task_id) {\n// //         queue[i] = task;\n// //         break;\n// //     }\n// // }\n// // global.set('taskQueue', queue);\n\n// // // ë””ë²„ê·¸ìš©\n// // node.warn({ action: 'TASK_ASSIGNED', task: task });\n\n// // // ì´ msgë¥¼ mqtt outìœ¼ë¡œ ë³´ë‚¼ ì¤€ë¹„\n// // msg.topic = 'robot/agv1/task';\n// // msg.payload = JSON.stringify(task);\n\n// // return msg;\n\n\n// // function3: Dispatcher/Scheduler v1\n// // í˜¸ì¶œ íƒ€ì´ë°:\n// //  1) ìƒˆ task ìƒì„± ì§í›„(function2 -> function3)\n// //  2) ë¡œë´‡ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„(updateStatus -> function3)\n// // ë™ì‘:\n// //  - ë¡œë´‡ì´ runningì´ë©´ ì•„ë¬´ ê²ƒë„ ì•ˆ í•¨\n// //  - idleì´ë©´ queueì—ì„œ ë‹¤ìŒ pending 1ê°œ êº¼ë‚´ì„œ runningìœ¼ë¡œ ì „í™˜ í›„ publish\n\n// const robotId = \"agv1\";\n\n// // 0) ê¸€ë¡œë²Œ ìƒíƒœ ì½ê¸°\n// let robots = global.get(\"robots\") || {};\n// let queue = global.get(\"taskQueue\") || [];\n\n// // robots ê¸°ë³¸ê°’ ë³´ì •\n// if (!robots[robotId]) {\n//     robots[robotId] = {\n//         robot_id: robotId,\n//         state: \"idle\",\n//         task_id: null,\n//         updated_at: Date.now()\n//     };\n// }\n\n// // 1) ë¡œë´‡ì´ ë°”ì˜ë©´ íŒ¨ìŠ¤ (ì´ê²Œ â€œë°”ì  ë•ŒëŠ” í• ë‹¹ ì•ˆ ë¨â€ì˜ ì •ì²´)\n// if (robots[robotId].state === \"running\") {\n//     return null;\n// }\n\n// // 2) queueì— ì´ë¯¸ runningì´ ìˆìœ¼ë©´(ìƒíƒœ ê¼¬ì„ ë°©ì§€) íŒ¨ìŠ¤\n// const hasRunning = queue.some(t => t.assigned_robot === robotId && t.status === \"running\");\n// if (hasRunning) return null;\n\n// // 3) ë‹¤ìŒ task ì„ íƒ (FIFO + í•„ìš”í•˜ë©´ type ìš°ì„ ìˆœìœ„)\n// // â€œë¬¼ ë¨¼ì €â€ ë³´ì¥ì„ ì›í•˜ë©´ PRIORITYë¥¼ ì‚¬ìš©\n// const PRIORITY = { deliver_water: 10, collect_cup: 20, collect_laundry: 30, unknown: 99 };\n\n// let candidates = queue\n//     .map((t, idx) => ({ t, idx }))\n//     .filter(x => (x.t.status === \"pending\" || x.t.status === \"queued\") && !x.t.assigned_robot);\n\n// if (candidates.length === 0) return null;\n\n// candidates.sort((a, b) => {\n//     const pa = PRIORITY[a.t.type] ?? 99;\n//     const pb = PRIORITY[b.t.type] ?? 99;\n//     if (pa !== pb) return pa - pb;\n//     return (a.t.created_at || 0) - (b.t.created_at || 0); // FIFO\n// });\n\n// let { t: task, idx } = candidates[0];\n\n// // 4) running ì „í™˜ + queue ë°˜ì˜\n// task.status = \"running\";\n// task.assigned_robot = robotId;\n// task.started_at = Date.now();\n\n// queue[idx] = task;\n// global.set(\"taskQueue\", queue);\n\n// // 5) robots ìƒíƒœë„ runningìœ¼ë¡œ ì„ ë°˜ì˜(ë ˆì´ìŠ¤ ë°©ì§€)\n// robots[robotId] = {\n//     ...robots[robotId],\n//     state: \"running\",\n//     task_id: task.task_id,\n//     updated_at: Date.now()\n// };\n// global.set(\"robots\", robots);\n\n// // 6) ë‹¤ìŒ ë…¸ë“œë“¤(FS update task, mqtt out)ë¡œ ë„˜ê¸¸ msg êµ¬ì„±\n// msg.task = task;\n// msg.topic = `robot/${robotId}/task`;\n// msg.payload = JSON.stringify(task);\n\n// node.warn({ action: \"TASK_DISPATCHED\", task_id: task.task_id, type: task.type });\n\n// return msg;\n\n\nconst robotId = \"agv1\";\nconst now = Date.now();\n\n// 0) ê¸€ë¡œë²Œ ìƒíƒœ ì½ê¸°\nlet robots = global.get(\"robots\") || {};\nlet queue = global.get(\"taskQueue\") || [];\n\n// âœ… NEW) (ì¤‘ìš”) msg.task / msg.payloadë¡œ ë“¤ì–´ì˜¨ taskë¥¼ global.taskQueueì— ìë™ìœ¼ë¡œ ë„£ì–´ì¤Œ\nlet incomingTask = msg.task || null;\nif (!incomingTask && typeof msg.payload === \"string\") {\n  try { incomingTask = JSON.parse(msg.payload); } catch {}\n}\nif (incomingTask && incomingTask.task_id) {\n  const exists = queue.some(t => t.task_id === incomingTask.task_id);\n  if (!exists) {\n    queue.push(incomingTask);\n    global.set(\"taskQueue\", queue);\n    node.warn({ action: \"ENQUEUE_TASK\", task_id: incomingTask.task_id, status: incomingTask.status, qlen: queue.length });\n  }\n}\n\n// robots ê¸°ë³¸ê°’ ë³´ì •\nif (!robots[robotId]) {\n  robots[robotId] = {\n    robot_id: robotId,\n    state: \"idle\",\n    task_id: null,\n    updated_at: now\n  };\n}\n\n// âœ… NEW) ë¡œë´‡ running stuck ë°©ì§€: ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ê°€ ë„ˆë¬´ ì˜¤ë˜ëìœ¼ë©´ idleë¡œ ë¦¬ì…‹(ì•ˆ ê·¸ëŸ¬ë©´ ì˜ì›íˆ dispatch ì•ˆ ë¨)\nconst STALE_MS = 15000;\nif (robots[robotId].state === \"running\") {\n  const upd = Number(robots[robotId].updated_at || 0);\n  if (upd && (now - upd > STALE_MS)) {\n    node.warn({ action: \"ROBOT_STALE_RESET\", robot_state: robots[robotId].state, task_id: robots[robotId].task_id, updated_at: upd });\n    robots[robotId].state = \"idle\";\n    robots[robotId].task_id = null;\n    robots[robotId].updated_at = now;\n    global.set(\"robots\", robots);\n  }\n}\n\n// 1) ë¡œë´‡ì´ ë°”ì˜ë©´ íŒ¨ìŠ¤\nif (robots[robotId].state === \"running\") {\n  node.warn({ action: \"DISPATCH_SKIP\", reason: \"robot_running\", robot: robots[robotId] });\n  return null;\n}\n\n// 2) queueì— ì´ë¯¸ runningì´ ìˆìœ¼ë©´ íŒ¨ìŠ¤\nconst hasRunning = queue.some(t => t.assigned_robot === robotId && t.status === \"running\");\nif (hasRunning) {\n  const rt = queue.find(t => t.assigned_robot === robotId && t.status === \"running\");\n  node.warn({ action: \"DISPATCH_SKIP\", reason: \"queue_has_running\", running_task: rt?.task_id, qlen: queue.length });\n  return null;\n}\n\n// 3) í›„ë³´ ì„ íƒ\nconst PRIORITY = { deliver_water: 10, collect_cup: 20, collect_laundry: 30, unknown: 99 };\n\nlet candidates = queue\n  .map((t, idx) => ({ t, idx }))\n  .filter(x => (x.t.status === \"pending\" || x.t.status === \"queued\") && !x.t.assigned_robot);\n\nif (candidates.length === 0) {\n  node.warn({ action: \"DISPATCH_SKIP\", reason: \"no_candidates\", qlen: queue.length, sample: queue.slice(-3) });\n  return null;\n}\n\ncandidates.sort((a, b) => {\n  const pa = PRIORITY[a.t.type] ?? 99;\n  const pb = PRIORITY[b.t.type] ?? 99;\n  if (pa !== pb) return pa - pb;\n  return (a.t.created_at || 0) - (b.t.created_at || 0);\n});\n\nlet { t: task, idx } = candidates[0];\n\n// 4) running ì „í™˜ + queue ë°˜ì˜\ntask.status = \"running\";\ntask.assigned_robot = robotId;\ntask.started_at = now;\n\nqueue[idx] = task;\nglobal.set(\"taskQueue\", queue);\n\n// 5) robots ìƒíƒœë„ runningìœ¼ë¡œ ì„ ë°˜ì˜\nrobots[robotId] = {\n  ...robots[robotId],\n  state: \"running\",\n  task_id: task.task_id,\n  updated_at: now\n};\nglobal.set(\"robots\", robots);\n\n// 6) mqttë¡œ ë³´ë‚¼ msg êµ¬ì„±\nmsg.task = task;\nmsg.topic = `robot/${robotId}/task`;\nmsg.payload = JSON.stringify(task);\n\nnode.warn({ action: \"TASK_DISPATCHED\", task_id: task.task_id, type: task.type, target_area: task.target_area });\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 1120,
        "wires": [
            [
                "58d8d616da6872e1",
                "fc7132a95c44fe84"
            ]
        ]
    },
    {
        "id": "c02ac5399c925f84",
        "type": "mqtt out",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3c16a07776b27396",
        "x": 2090,
        "y": 1120,
        "wires": []
    },
    {
        "id": "084632d493b02014",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 1140,
        "wires": []
    },
    {
        "id": "a8cdfef7f11748d6",
        "type": "mqtt in",
        "z": "49f8711fc297a8c1",
        "name": "robot status",
        "topic": "robot/+/status",
        "qos": "2",
        "datatype": "utf8",
        "broker": "3c16a07776b27396",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 350,
        "y": 1240,
        "wires": [
            [
                "95ebc22a961575da"
            ]
        ]
    },
    {
        "id": "95ebc22a961575da",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "function(updateStatus)",
        "func": "// // robot/+/status ë¡œë¶€í„° ë“¤ì–´ì˜¤ëŠ” msgë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜\n\n// // 1) payload JSON íŒŒì‹±\n// let status;\n// try {\n//     status = JSON.parse(msg.payload || '{}');\n// } catch (e) {\n//     node.error('Invalid JSON in robot status', msg);\n//     return null;\n// }\n\n// // 2) í† í”½ì—ì„œ robot_id ì¶”ì¶œ: robot/agv1/status\n// const parts = msg.topic.split('/');\n// const robotIdFromTopic = parts[1] || null;\n// const robotId = status.robot_id || robotIdFromTopic || 'unknown';\n\n// // 3) robots ìƒíƒœ ê°±ì‹  (global.robots)\n// let robots = global.get('robots') || {};\n// const now = Date.now();\n// robots[robotId] = {\n//     // ê¸°ì¡´ ê°’ ìœ ì§€(ì¶”ê°€ í•„ë“œ ì•ˆ ë‚ ë¦¬ê¸°)\n//     ...(robots[robotId] || {}),\n\n//     // í‘œì¤€ í•„ë“œ\n//     robot_id: robotId,\n//     state: status.state || 'unknown',\n//     task_id: status.task_id || null,\n//     battery: (status.battery !== undefined) ? status.battery : (robots[robotId]?.battery ?? null),\n//     area: status.area || null,\n//     error_code: status.error_code || null,\n//     cpu_temp: status.cpu_temp || null,\n\n//     // ë””ì§€í„¸ íŠ¸ìœˆ í•µì‹¬ í•„ë“œ (ì¶”ê°€)\n//     pose: status.pose || (robots[robotId]?.pose ?? null),\n//     target_area: status.target_area || (robots[robotId]?.target_area ?? null),\n\n//     updated_at: status.updated_at || now\n\n//     // âœ… [ìˆ˜ì •] ë°°í„°ë¦¬ëŠ” ì´ì œ statusì—ì„œ ì˜¨ ì§„ì§œ ê°’ì„ ì”ë‹ˆë‹¤\n    \n//     // âœ… [ì¶”ê°€] CPU ì˜¨ë„ ì €ì¥ (íŒ€ì› ìš”ì²­ ëŒ€ì‘)\n    \n// };\n// global.set('robots', robots);\n\n// // ----------------------\n// // EMA stats helpers\n// // ----------------------\n// let taskStats = global.get(\"taskStats\") || {};  // { deliver_water: { ema_ms, n, updated_at }, ... }\n// const EMA_ALPHA = 0.3;\n\n// function emaUpdate(key, sampleMs) {\n//     const prev = taskStats[key]?.ema_ms;\n//     const next = (prev == null) ? sampleMs : (EMA_ALPHA * sampleMs + (1 - EMA_ALPHA) * prev);\n//     taskStats[key] = {\n//         ema_ms: next,\n//         n: (taskStats[key]?.n || 0) + 1,\n//         updated_at: Date.now()\n//     };\n// }\n\n// // 4) taskQueue/events ë°˜ì˜ (task_id ìˆì„ ë•Œë§Œ)\n// let taskQueue = global.get('taskQueue') || [];\n// let events = global.get('events') || [];\n\n// if (status.task_id) {\n//     const taskId = status.task_id;\n\n//     for (let i = 0; i < taskQueue.length; i++) {\n//         if (taskQueue[i].task_id === taskId) {\n\n//             if (status.state === 'done' || status.state === 'idle') {\n//                 taskQueue[i].status = 'done';\n//                 taskQueue[i].finished_at = Date.now();\n\n//                 // âœ… ì¶”ê°€: ì‹¤ì œ ê±¸ë¦° ì‹œê°„ ê³„ì‚° + EMA ì—…ë°ì´íŠ¸\n//                 const started = taskQueue[i].started_at || taskQueue[i].created_at || taskQueue[i].finished_at;\n//                 const actualMs = Math.max(0, taskQueue[i].finished_at - started);\n//                 taskQueue[i].actual_duration_ms = actualMs;\n\n//                 const key = taskQueue[i].type || \"unknown\"; // ë” ì„¸ë¶„í™” ì›í•˜ë©´ `${type}|${target_area}`\n//                 emaUpdate(key, actualMs);\n//                 global.set(\"taskStats\", taskStats);\n//             } else if (status.state === 'running') {\n//                 taskQueue[i].status = 'running';\n//                 if (!taskQueue[i].started_at) taskQueue[i].started_at = Date.now();\n//             } else if (status.state === 'error') {\n//                 taskQueue[i].status = 'failed';\n//                 taskQueue[i].finished_at = Date.now();\n//                 taskQueue[i].error_code = status.error_code || null;\n\n//                 // âœ… ì¶”ê°€: ì‹¤ì œ ê±¸ë¦° ì‹œê°„ ê³„ì‚° + EMA ì—…ë°ì´íŠ¸\n//                 const started = taskQueue[i].started_at || taskQueue[i].created_at || taskQueue[i].finished_at;\n//                 const actualMs = Math.max(0, taskQueue[i].finished_at - started);\n//                 taskQueue[i].actual_duration_ms = actualMs;\n\n//                 const key = taskQueue[i].type || \"unknown\";\n//                 emaUpdate(key, actualMs);\n//                 global.set(\"taskStats\", taskStats);\n//             }\n\n//             taskQueue[i].assigned_robot = robotId;\n//             break;\n//         }\n//     }\n//     global.set('taskQueue', taskQueue);\n\n//     events.push({\n//         ts: Date.now(),\n//         type: 'task_status_update',\n//         robot_id: robotId,\n//         task_id: taskId,\n//         state: status.state,\n//         area: status.area || null,\n//         target_area: status.target_area || null,\n//         pose: status.pose || null,\n//         error_code: status.error_code || null\n//     });\n\n//     if (events.length > 200) events = events.slice(events.length - 200);\n//     global.set('events', events);\n// }\n\n// // 5) ë””ë²„ê·¸ payload ì„¸íŒ…\n// msg.payload = {\n//     last_status: status,\n//     robots: robots\n// };\n\n// // ----------------------\n// // Firestore write (ì¶”ê°€)\n// // ----------------------\n// const db = global.get(\"db\");\n// if (db) {\n//     // robots/{robotId}\n//     db.collection(\"robots\").doc(robotId).set(robots[robotId], { merge: true })\n//         .catch(err => node.error(\"[robots write] \" + err));\n\n//     // tasks/{task_id} (ìˆì„ ë•Œë§Œ)\n//     if (status.task_id) {\n//         const mappedStatus =\n//             (status.state === \"error\") ? \"failed\" :\n//             (status.state === \"done\" || status.state === \"idle\") ? \"done\" :\n//             (status.state === \"running\") ? \"running\" : \"unknown\";\n\n//         const taskPatch = {\n//             status: mappedStatus,\n//             assigned_robot: robotId,\n//             error_code: status.error_code || null,\n//         };\n\n//         const tq = global.get(\"taskQueue\") || [];\n//         const tt = tq.find(x => x.task_id === status.task_id);\n//         if (tt?.actual_duration_ms != null) taskPatch.actual_duration_ms = tt.actual_duration_ms;\n//         if (tt?.expected_duration_ms != null) taskPatch.expected_duration_ms = tt.expected_duration_ms;\n\n//         if (status.state === \"done\" || status.state === \"idle\" || status.state === \"error\") {\n//             taskPatch.finished_at = Date.now();\n//         }\n\n//         db.collection(\"tasks\").doc(status.task_id).set(taskPatch, { merge: true })\n//             .catch(err => node.error(\"[tasks write] \" + err));\n//     }\n\n//     // events add\n//     db.collection(\"events\").add({\n//         ts: Date.now(),\n//         type: \"task_status_update\",\n//         robot_id: robotId,\n//         task_id: status.task_id || null,\n//         state: status.state || null,\n//         area: status.area || null,\n//         target_area: status.target_area || null,\n//         pose: status.pose || null,\n//         error_code: status.error_code || null\n//     }).catch(err => node.error(\"[events add] \" + err));\n// }\n\n// return msg;\n\n\n\n\n// robot/+/status ë¡œë¶€í„° ë“¤ì–´ì˜¤ëŠ” msgë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜\n\n// 1) payload JSON íŒŒì‹±\nlet status;\ntry {\n    status = JSON.parse(msg.payload || '{}');\n} catch (e) {\n    node.error('Invalid JSON in robot status', msg);\n    return null;\n}\n\n// 2) í† í”½ì—ì„œ robot_id ì¶”ì¶œ: robot/agv1/status\nconst parts = msg.topic.split('/');\nconst robotIdFromTopic = parts[1] || null;\nconst robotId = status.robot_id || robotIdFromTopic || 'unknown';\n\n// 3) robots ìƒíƒœ ê°±ì‹  (global.robots)\nlet robots = global.get('robots') || {};\nconst now = Date.now();\nrobots[robotId] = {\n    // ê¸°ì¡´ ê°’ ìœ ì§€\n    ...(robots[robotId] || {}),\n\n    // í‘œì¤€ í•„ë“œ\n    robot_id: robotId,\n    state: status.state || 'unknown',\n    task_id: status.task_id || null,\n    battery: (status.battery !== undefined) ? status.battery : (robots[robotId]?.battery ?? null),\n    area: status.area || null,\n    error_code: status.error_code || null,\n    cpu_temp: status.cpu_temp || null,\n\n    // ë””ì§€í„¸ íŠ¸ìœˆ í•µì‹¬ í•„ë“œ\n    pose: status.pose || (robots[robotId]?.pose ?? null),\n    target_area: status.target_area || (robots[robotId]?.target_area ?? null),\n\n    updated_at: status.updated_at || now\n};\nglobal.set('robots', robots);\n\n// ----------------------\n// EMA stats helpers\n// ----------------------\nlet taskStats = global.get(\"taskStats\") || {};\nconst EMA_ALPHA = 0.3;\n\nfunction emaUpdate(key, sampleMs) {\n    const prev = taskStats[key]?.ema_ms;\n    const next = (prev == null) ? sampleMs : (EMA_ALPHA * sampleMs + (1 - EMA_ALPHA) * prev);\n    taskStats[key] = {\n        ema_ms: next,\n        n: (taskStats[key]?.n || 0) + 1,\n        updated_at: Date.now()\n    };\n}\n\n// 4) taskQueue/events ë°˜ì˜ (task_id ìˆì„ ë•Œë§Œ)\nlet taskQueue = global.get('taskQueue') || [];\nlet events = global.get('events') || [];\nlet telegramMsg = null; // â˜… ì•Œë¦¼ ë©”ì‹œì§€ ë³€ìˆ˜ ì¶”ê°€\n\nif (status.task_id) {\n    const taskId = status.task_id;\n\n    for (let i = 0; i < taskQueue.length; i++) {\n        if (taskQueue[i].task_id === taskId) {\n            \n            // â˜… ì¤‘ìš”: ì´ë¯¸ ì™„ë£Œëœ ì‘ì—…ì¸ì§€ í™•ì¸ (ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€)\n            const isJustFinished = (taskQueue[i].status !== 'done' && taskQueue[i].status !== 'failed');\n\n            if (status.state === 'done' || status.state === 'idle') {\n                taskQueue[i].status = 'done';\n                taskQueue[i].finished_at = Date.now();\n\n                // ì‹¤ì œ ê±¸ë¦° ì‹œê°„ ê³„ì‚° + EMA ì—…ë°ì´íŠ¸\n                const started = taskQueue[i].started_at || taskQueue[i].created_at || taskQueue[i].finished_at;\n                const actualMs = Math.max(0, taskQueue[i].finished_at - started);\n                taskQueue[i].actual_duration_ms = actualMs;\n\n                const key = taskQueue[i].type || \"unknown\";\n                emaUpdate(key, actualMs);\n                global.set(\"taskStats\", taskStats);\n\n                // â˜…â˜…â˜… [ì—¬ê¸° ì¶”ê°€ë¨] í…”ë ˆê·¸ë¨ ì•Œë¦¼ ìƒì„± â˜…â˜…â˜…\n                // ë°©ê¸ˆ ë§‰ ëë‚¬ê³ , í…”ë ˆê·¸ë¨ ìœ ì €(tg_...)ì¸ ê²½ìš°ì—ë§Œ\n                if (isJustFinished && taskQueue[i].user_id && taskQueue[i].user_id.startsWith('tg_')) {\n                    const chatId = taskQueue[i].user_id.replace('tg_', '');\n                    \n                    // ì‘ì—… ì´ë¦„ ì˜ˆì˜ê²Œ\n                    let taskName = taskQueue[i].type;\n                    if(taskName === 'deliver_water') taskName = 'â˜• ë¬¼ ë°°ë‹¬';\n                    else if(taskName === 'collect_cup') taskName = 'ğŸ¥¤ ì»µ ìˆ˜ê±°';\n                    else if(taskName === 'collect_laundry') taskName = 'ğŸ§¹ í™˜ê²½ ì •ë¦¬';\n                    else taskName = 'ìš”ì²­í•˜ì‹  ì‘ì—…';\n\n                    telegramMsg = {\n                        payload: {\n                            chatId: chatId,\n                            type: \"message\",\n                            content: `âœ… ${taskName} ì™„ë£Œ!\\nìš”ì²­í•˜ì‹  ì‘ì—…ì„ ëª¨ë‘ ë§ˆì³¤ì–´ìš”. ğŸ‰`,\n                            options: {}\n                        }\n                    };\n                }\n\n            } else if (status.state === 'running') {\n                taskQueue[i].status = 'running';\n                if (!taskQueue[i].started_at) taskQueue[i].started_at = Date.now();\n            } else if (status.state === 'error') {\n                taskQueue[i].status = 'failed';\n                taskQueue[i].finished_at = Date.now();\n                taskQueue[i].error_code = status.error_code || null;\n\n                // ì—ëŸ¬ ì‹œì—ë„ í†µê³„ ì—…ë°ì´íŠ¸\n                const started = taskQueue[i].started_at || taskQueue[i].created_at || taskQueue[i].finished_at;\n                const actualMs = Math.max(0, taskQueue[i].finished_at - started);\n                taskQueue[i].actual_duration_ms = actualMs;\n                \n                const key = taskQueue[i].type || \"unknown\";\n                emaUpdate(key, actualMs);\n                global.set(\"taskStats\", taskStats);\n                \n                // (ì„ íƒ ì‚¬í•­) ì—ëŸ¬ ì‹œ ì•Œë¦¼ë„ ë³´ë‚´ê³  ì‹¶ë‹¤ë©´ ì—¬ê¸°ì— telegramMsg ë¡œì§ ì¶”ê°€ ê°€ëŠ¥\n            }\n\n            taskQueue[i].assigned_robot = robotId;\n            break;\n        }\n    }\n    global.set('taskQueue', taskQueue);\n\n    // ì´ë²¤íŠ¸ ë¡œê·¸ ê¸°ë¡\n    events.push({\n        ts: Date.now(),\n        type: 'task_status_update',\n        robot_id: robotId,\n        task_id: taskId,\n        state: status.state,\n        area: status.area || null,\n        target_area: status.target_area || null,\n        pose: status.pose || null,\n        error_code: status.error_code || null\n    });\n\n    if (events.length > 200) events = events.slice(events.length - 200);\n    global.set('events', events);\n}\n\n// 5) ë””ë²„ê·¸ payload ì„¸íŒ…\nmsg.payload = {\n    last_status: status,\n    robots: robots\n};\n\n// ----------------------\n// Firestore write\n// ----------------------\nconst db = global.get(\"db\");\nif (db) {\n    db.collection(\"robots\").doc(robotId).set(robots[robotId], { merge: true })\n        .catch(err => node.error(\"[robots write] \" + err));\n\n    if (status.task_id) {\n        const mappedStatus =\n            (status.state === \"error\") ? \"failed\" :\n            (status.state === \"done\" || status.state === \"idle\") ? \"done\" :\n            (status.state === \"running\") ? \"running\" : \"unknown\";\n\n        const taskPatch = {\n            status: mappedStatus,\n            assigned_robot: robotId,\n            error_code: status.error_code || null,\n        };\n\n        const tq = global.get(\"taskQueue\") || [];\n        const tt = tq.find(x => x.task_id === status.task_id);\n        if (tt?.actual_duration_ms != null) taskPatch.actual_duration_ms = tt.actual_duration_ms;\n        if (tt?.expected_duration_ms != null) taskPatch.expected_duration_ms = tt.expected_duration_ms;\n\n        if (status.state === \"done\" || status.state === \"idle\" || status.state === \"error\") {\n            taskPatch.finished_at = Date.now();\n        }\n\n        db.collection(\"tasks\").doc(status.task_id).set(taskPatch, { merge: true })\n            .catch(err => node.error(\"[tasks write] \" + err));\n    }\n\n    db.collection(\"events\").add({\n        ts: Date.now(),\n        type: \"task_status_update\",\n        robot_id: robotId,\n        task_id: status.task_id || null,\n        state: status.state || null,\n        area: status.area || null,\n        target_area: status.target_area || null,\n        pose: status.pose || null,\n        error_code: status.error_code || null\n    }).catch(err => node.error(\"[events add] \" + err));\n}\n\n// â˜…â˜…â˜… ì¤‘ìš”: [ì›ë˜ ë©”ì‹œì§€, í…”ë ˆê·¸ë¨ ë©”ì‹œì§€] 2ê°œ ì¶œë ¥\nreturn [msg, telegramMsg];",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 1240,
        "wires": [
            [
                "0ea75d0a1dd47579",
                "8fa070ba704430fc"
            ],
            [
                "d1e13ead5e796c2d"
            ]
        ]
    },
    {
        "id": "0ea75d0a1dd47579",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 1240,
        "wires": []
    },
    {
        "id": "b9b40ef75eda6086",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "refresh robots",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 520,
        "y": 3380,
        "wires": [
            [
                "62da11a590d356e1"
            ]
        ]
    },
    {
        "id": "62da11a590d356e1",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "getRobots",
        "func": "const robots = global.get('robots') || {};\nconst arr = [];\n\nfor (const id in robots) {\n    const r = robots[id];\n    // updated_at ëˆ„ë½ ë°©ì–´\n    if (!r.updated_at) r.updated_at = Date.now();\n    arr.push(r);\n}\n\nmsg.robots = arr;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 3380,
        "wires": [
            [
                "b1495853d26db37c"
            ]
        ]
    },
    {
        "id": "c8bbc855845ed80c",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "refresh tasks",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 520,
        "y": 3440,
        "wires": [
            [
                "49c2e81ae9744bc4"
            ]
        ]
    },
    {
        "id": "49c2e81ae9744bc4",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "getTasks",
        "func": "let tasks = global.get('taskQueue') || [];\n\n// ìµœê·¼ ìƒì„±ëœ ìˆœì„œëŒ€ë¡œ ë³´ê³  ì‹¶ìœ¼ë©´ ì •ë ¬\ntasks = tasks.slice().sort((a, b) => (b.created_at || 0) - (a.created_at || 0));\n\nmsg.tasks = tasks;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 3440,
        "wires": [
            [
                "c915a198b0c6cae3"
            ]
        ]
    },
    {
        "id": "6867664da4b8f9fd",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "refresh events",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 520,
        "y": 3500,
        "wires": [
            [
                "b6c7d07a0458179a"
            ]
        ]
    },
    {
        "id": "b6c7d07a0458179a",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "getEvents",
        "func": "let events = global.get('events') || [];\n\n// ìµœì‹  ì´ë²¤íŠ¸ê°€ ìœ„ì— ë³´ì´ë„ë¡ ì—­ìˆœ ì •ë ¬\nevents = events.slice().sort((a, b) => (b.ts || 0) - (a.ts || 0));\n\nmsg.events = events;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 3500,
        "wires": [
            [
                "5b2975efe1ee8e3a"
            ]
        ]
    },
    {
        "id": "b1495853d26db37c",
        "type": "ui_template",
        "z": "49f8711fc297a8c1",
        "group": "e6e1b7942a2b8330",
        "name": "Robots cards",
        "order": 0,
        "width": 0,
        "height": 0,
        "format": "<div class=\"robots-wrapper\">\n  <div ng-repeat=\"r in msg.robots\" \n       class=\"robot-card\" \n       ng-class=\"(r.state || 'unknown').toLowerCase()\">\n       \n    <div class=\"robot-header\">\n      <span class=\"robot-id\">{{r.robot_id}}</span>\n      <span class=\"state-pill\" \n            ng-class=\"(r.state || 'unknown').toLowerCase()\">\n        {{(r.state || 'unknown') | uppercase}}\n      </span>\n    </div>\n\n    <div class=\"robot-main\">\n      <div class=\"battery\">\n        ğŸ”‹ {{r.battery !== null && r.battery !== undefined ? (r.battery + '%') : '-'}}\n      </div>\n      <div class=\"area\">\n        ğŸ“ {{r.area || '-'}}\n      </div>\n      <div class=\"task\">\n        ğŸ§¾ {{r.task_id || '-'}}\n      </div>\n      <div class=\"error\" ng-if=\"r.error_code\">\n        âš  ERROR: {{r.error_code}}\n      </div>\n    </div>\n\n    <div class=\"robot-footer\">\n      <span class=\"updated-label\">UPDATED</span>\n      <span class=\"updated-at\">\n        {{ r.updated_at | date:'HH:mm:ss' }}\n      </span>\n    </div>\n  </div>\n\n  <div ng-if=\"!msg.robots || msg.robots.length === 0\" class=\"robot-empty\">\n    No robot data yet.\n  </div>\n</div>\n\n<style>\n  .robots-wrapper {\n    display:flex;\n    flex-wrap:wrap;\n    gap:16px;\n    padding-top:4px;\n  }\n  .robot-card {\n    width: 220px;\n    background: radial-gradient(circle at top left, #0f172a, #020617);\n    border-radius:16px;\n    padding:12px 14px;\n    box-shadow:0 0 18px rgba(15,23,42,0.9);\n    border:1px solid rgba(148,163,184,0.35);\n    color:#E5E7EB;\n    display:flex;\n    flex-direction:column;\n    justify-content:space-between;\n  }\n  .robot-header {\n    display:flex;\n    justify-content:space-between;\n    align-items:center;\n    margin-bottom:8px;\n  }\n  .robot-id {\n    font-weight:700;\n    font-size:16px;\n    color:#F9FAFB;\n  }\n  .state-pill {\n    padding:2px 8px;\n    border-radius:999px;\n    font-size:10px;\n    font-weight:600;\n    letter-spacing:0.5px;\n    border:1px solid rgba(148,163,184,0.5);\n  }\n  .state-pill.idle {\n    background:rgba(148,163,184,0.15);\n    border-color:#9CA3AF;\n    color:#E5E7EB;\n  }\n  .state-pill.running {\n    background:rgba(34,197,94,0.15);\n    border-color:#22C55E;\n    color:#BBF7D0;\n  }\n  .state-pill.charging {\n    background:rgba(234,179,8,0.12);\n    border-color:#EAB308;\n    color:#FEF9C3;\n  }\n  .state-pill.error, .state-pill.failed, .state-pill.fault {\n    background:rgba(239,68,68,0.16);\n    border-color:#EF4444;\n    color:#FECACA;\n  }\n  .state-pill.unknown {\n    background:rgba(59,130,246,0.12);\n    border-color:#3B82F6;\n    color:#BFDBFE;\n  }\n\n  .robot-main {\n    font-size:13px;\n    line-height:1.4;\n    margin-top:4px;\n    margin-bottom:8px;\n  }\n  .robot-main > div {\n    margin:2px 0;\n  }\n  .robot-main .error {\n    color:#FCA5A5;\n    font-size:12px;\n  }\n\n  .robot-footer {\n    display:flex;\n    justify-content:space-between;\n    font-size:10px;\n    color:#9CA3AF;\n    border-top:1px dashed rgba(55,65,81,0.8);\n    padding-top:4px;\n    margin-top:4px;\n  }\n  .robot-empty {\n    font-size:12px;\n    color:#9CA3AF;\n    padding:10px;\n  }\n</style>\n",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 1150,
        "y": 3380,
        "wires": [
            []
        ]
    },
    {
        "id": "4cc056840f379311",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "Summary",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 510,
        "y": 3320,
        "wires": [
            [
                "cc62e9eae576026f"
            ]
        ]
    },
    {
        "id": "cc62e9eae576026f",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "Summary",
        "func": "// robots ìš”ì•½\nconst robots = global.get('robots') || {};\nconst taskQueue = global.get('taskQueue') || [];\n\nlet total = 0, idle = 0, running = 0, charging = 0, error = 0, others = 0;\n\nfor (const id in robots) {\n    total++;\n    const s = (robots[id].state || '').toLowerCase();\n    if (s === 'idle') idle++;\n    else if (s === 'running') running++;\n    else if (s === 'charging') charging++;\n    else if (s === 'error' || s === 'failed' || s === 'fault') error++;\n    else others++;\n}\n\nmsg.summary = { total, idle, running, charging, error, others };\n\n// tasks ìš”ì•½\nlet tTotal = taskQueue.length;\nlet tPending = 0, tRunning = 0, tDone = 0, tFailed = 0;\n\nfor (const t of taskQueue) {\n    const s = (t.status || '').toLowerCase();\n    if (s === 'pending') tPending++;\n    else if (s === 'running') tRunning++;\n    else if (s === 'done') tDone++;\n    else if (s === 'failed') tFailed++;\n}\n\nmsg.taskSummary = {\n    total: tTotal,\n    pending: tPending,\n    running: tRunning,\n    done: tDone,\n    failed: tFailed\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 3320,
        "wires": [
            [
                "74d6b228f443bd37"
            ]
        ]
    },
    {
        "id": "74d6b228f443bd37",
        "type": "ui_template",
        "z": "49f8711fc297a8c1",
        "group": "7e8e44e7110066b9",
        "name": "",
        "order": 0,
        "width": 0,
        "height": 0,
        "format": "<div class=\"dash-summary\">\n  <div class=\"summary-card total\">\n    <div class=\"label\">ROBOTS</div>\n    <div class=\"value\">{{msg.summary.total || 0}}</div>\n  </div>\n  <div class=\"summary-card idle\">\n    <div class=\"label\">IDLE</div>\n    <div class=\"value\">{{msg.summary.idle || 0}}</div>\n  </div>\n  <div class=\"summary-card running\">\n    <div class=\"label\">RUNNING</div>\n    <div class=\"value\">{{msg.summary.running || 0}}</div>\n  </div>\n  <div class=\"summary-card charging\">\n    <div class=\"label\">CHARGING</div>\n    <div class=\"value\">{{msg.summary.charging || 0}}</div>\n  </div>\n  <div class=\"summary-card error\">\n    <div class=\"label\">ERROR/OTHER</div>\n    <div class=\"value\">\n      {{(msg.summary.error || 0) + (msg.summary.others || 0)}}\n    </div>\n  </div>\n</div>\n\n<div class=\"dash-summary\" style=\"margin-top:6px;\">\n  <div class=\"summary-card task-total\">\n    <div class=\"label\">TASKS</div>\n    <div class=\"value\">{{msg.taskSummary.total || 0}}</div>\n  </div>\n  <div class=\"summary-card task-pending\">\n    <div class=\"label\">PENDING</div>\n    <div class=\"value\">{{msg.taskSummary.pending || 0}}</div>\n  </div>\n  <div class=\"summary-card task-running\">\n    <div class=\"label\">RUNNING</div>\n    <div class=\"value\">{{msg.taskSummary.running || 0}}</div>\n  </div>\n  <div class=\"summary-card task-done\">\n    <div class=\"label\">DONE</div>\n    <div class=\"value\">{{msg.taskSummary.done || 0}}</div>\n  </div>\n  <div class=\"summary-card task-failed\">\n    <div class=\"label\">FAILED</div>\n    <div class=\"value\">{{msg.taskSummary.failed || 0}}</div>\n  </div>\n</div>\n\n<style>\n  .dash-summary {\n    display:flex;\n    flex-wrap:wrap;\n    gap:16px;\n    padding:4px 0 4px 0;\n  }\n  .summary-card {\n    flex:0 0 150px;\n    background:#020617;\n    border-radius:14px;\n    padding:10px 14px;\n    box-shadow:0 0 18px rgba(0,0,0,0.45);\n    border:1px solid rgba(148,163,184,0.25);\n  }\n  .summary-card .label {\n    font-size:11px;\n    letter-spacing:1px;\n    color:#9CA3AF;\n  }\n  .summary-card .value {\n    margin-top:4px;\n    font-size:22px;\n    font-weight:700;\n    color:#F9FAFB;\n  }\n\n  .summary-card.total      { border-left:3px solid #38BDF8; }\n  .summary-card.idle       { border-left:3px solid #9CA3AF; }\n  .summary-card.running    { border-left:3px solid #22C55E; }\n  .summary-card.charging   { border-left:3px solid #EAB308; }\n  .summary-card.error      { border-left:3px solid #EF4444; }\n\n  .summary-card.task-total   { border-left:3px solid #6366F1; }\n  .summary-card.task-pending { border-left:3px solid #9CA3AF; }\n  .summary-card.task-running { border-left:3px solid #22C55E; }\n  .summary-card.task-done    { border-left:3px solid #0EA5E9; }\n  .summary-card.task-failed  { border-left:3px solid #F97316; }\n</style>\n",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 1140,
        "y": 3320,
        "wires": [
            []
        ]
    },
    {
        "id": "c915a198b0c6cae3",
        "type": "ui_template",
        "z": "49f8711fc297a8c1",
        "group": "920df32220cd089d",
        "name": "",
        "order": 0,
        "width": 0,
        "height": 0,
        "format": "<div class=\"tasks-wrapper\">\n  <table class=\"tasks-table\" ng-if=\"msg.tasks && msg.tasks.length\">\n    <thead>\n      <tr>\n        <th>Task ID</th>\n        <th>Type</th>\n        <th>Target</th>\n        <th>Status</th>\n        <th>Robot</th>\n        <th>Created</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"t in msg.tasks\">\n        <td>{{t.task_id}}</td>\n        <td>{{t.type}}</td>\n        <td>{{t.target_area}}</td>\n        <td>\n          <span class=\"task-status\" ng-class=\"(t.status || 'unknown').toLowerCase()\">\n            {{(t.status || 'unknown') | uppercase}}\n          </span>\n        </td>\n        <td>{{t.assigned_robot || '-'}}</td>\n        <td>{{t.created_at | date:'MM-dd HH:mm:ss'}}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <div ng-if=\"!msg.tasks || !msg.tasks.length\" class=\"tasks-empty\">\n    No tasks yet.\n  </div>\n</div>\n\n<style>\n  .tasks-wrapper {\n    padding-top:4px;\n  }\n  .tasks-table {\n    width:100%;\n    border-collapse:collapse;\n    font-size:12px;\n    background:#020617;\n    border-radius:10px;\n    overflow:hidden;\n    box-shadow:0 0 18px rgba(15,23,42,0.7);\n  }\n  .tasks-table thead {\n    background:linear-gradient(to right,#0f172a,#020617);\n  }\n  .tasks-table th,\n  .tasks-table td {\n    padding:6px 8px;\n    text-align:left;\n    border-bottom:1px solid rgba(30,41,59,0.9);\n    color:#E5E7EB;\n  }\n  .tasks-table th {\n    font-weight:600;\n    font-size:11px;\n    color:#9CA3AF;\n  }\n  .tasks-table tbody tr:hover {\n    background:rgba(15,23,42,0.8);\n  }\n\n  .task-status {\n    padding:2px 6px;\n    border-radius:999px;\n    font-size:10px;\n    border:1px solid rgba(148,163,184,0.4);\n  }\n  .task-status.pending {\n    background:rgba(148,163,184,0.1);\n    border-color:#9CA3AF;\n  }\n  .task-status.running {\n    background:rgba(34,197,94,0.15);\n    border-color:#22C55E;\n    color:#BBF7D0;\n  }\n  .task-status.done {\n    background:rgba(59,130,246,0.18);\n    border-color:#3B82F6;\n    color:#DBEAFE;\n  }\n  .task-status.failed {\n    background:rgba(239,68,68,0.18);\n    border-color:#EF4444;\n    color:#FECACA;\n  }\n  .task-status.unknown {\n    background:rgba(107,114,128,0.18);\n    border-color:#6B7280;\n    color:#E5E7EB;\n  }\n\n  .tasks-empty {\n    font-size:12px;\n    color:#9CA3AF;\n    padding:8px;\n  }\n</style>\n",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 1140,
        "y": 3440,
        "wires": [
            []
        ]
    },
    {
        "id": "5b2975efe1ee8e3a",
        "type": "ui_template",
        "z": "49f8711fc297a8c1",
        "group": "ab2f507577ca5dbe",
        "name": "",
        "order": 0,
        "width": 0,
        "height": 0,
        "format": "<div class=\"events-wrapper\">\n  <table class=\"events-table\" ng-if=\"msg.events && msg.events.length\">\n    <thead>\n      <tr>\n        <th>Time</th>\n        <th>Type</th>\n        <th>Robot</th>\n        <th>Task</th>\n        <th>State</th>\n        <th>Area</th>\n        <th>Error</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"e in msg.events | limitTo:50\">\n        <td>{{e.ts | date:'HH:mm:ss'}}</td>\n        <td>{{e.type}}</td>\n        <td>{{e.robot_id}}</td>\n        <td>{{e.task_id}}</td>\n        <td>{{e.state}}</td>\n        <td>{{e.area || '-'}}</td>\n        <td>{{e.error_code || '-'}}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <div ng-if=\"!msg.events || !msg.events.length\" class=\"events-empty\">\n    No events yet.\n  </div>\n</div>\n\n<style>\n  .events-wrapper {\n    padding-top:4px;\n  }\n  .events-table {\n    width:100%;\n    border-collapse:collapse;\n    font-size:11px;\n    background:#020617;\n    border-radius:10px;\n    overflow:hidden;\n    box-shadow:0 0 18px rgba(15,23,42,0.7);\n  }\n  .events-table thead {\n    background:linear-gradient(to right,#0f172a,#020617);\n  }\n  .events-table th,\n  .events-table td {\n    padding:4px 6px;\n    text-align:left;\n    border-bottom:1px solid rgba(30,41,59,0.9);\n    color:#E5E7EB;\n  }\n  .events-table th {\n    font-weight:600;\n    font-size:10px;\n    color:#9CA3AF;\n  }\n  .events-table tbody tr:hover {\n    background:rgba(15,23,42,0.8);\n  }\n  .events-empty {\n    font-size:12px;\n    color:#9CA3AF;\n    padding:8px;\n  }\n</style>\n",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 1140,
        "y": 3500,
        "wires": [
            []
        ]
    },
    {
        "id": "f4058cf1557c02ec",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "Init global state",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 360,
        "y": 180,
        "wires": [
            [
                "dd5be1ad5697a1f2"
            ]
        ]
    },
    {
        "id": "dd5be1ad5697a1f2",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "initGlobalState",
        "func": "// // InitGlobalState (TRACK_POINTS + AREA_POS snap-to-track + agv1 init)\n\n// // -------------------------\n// // 0) Track generator (percent coords 0~100)\n// // -------------------------\n// function addLine(pts, a, b, steps) {\n//   for (let i = 1; i <= steps; i++) {\n//     const t = i / steps;\n//     pts.push({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });\n//   }\n// }\n\n// function addArc(pts, cx, cy, r, a0, a1, steps) {\n//   for (let i = 1; i <= steps; i++) {\n//     const t = i / steps;\n//     const a = a0 + (a1 - a0) * t;\n//     pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });\n//   }\n// }\n\n// // \"ë‘¥ê·¼ ì‚¬ê° ë£¨í”„\"ë¥¼ ë§Œë“  ë’¤, ì¢Œ/ìš°ì— ì‚´ì§ êµ´ê³¡ì„ ì¤˜ì„œ ì‹¤ì œ íŠ¸ë™ ëŠë‚Œì„ ì¡°ê¸ˆ ëƒ„\n// function makeTrackV1() {\n//   const l = 16, t = 14, r = 86, b = 86;  // íŠ¸ë™ ë°”ìš´ë”© ë°•ìŠ¤ (í¼ì„¼íŠ¸)\n//   const rad = 16;                        // ì½”ë„ˆ ë¼ìš´ë“œ\n//   const pts = [];\n\n//   // ì‹œì‘ì : top edgeì˜ left ë¼ìš´ë“œ ë\n//   pts.push({ x: l + rad, y: t });\n\n//   // top (left->right)\n//   addLine(pts, pts[pts.length - 1], { x: r - rad, y: t }, 40);\n//   // top-right corner (-90 -> 0)\n//   addArc(pts, r - rad, t + rad, rad, -Math.PI / 2, 0, 22);\n\n//   // right (top->bottom)\n//   addLine(pts, pts[pts.length - 1], { x: r, y: b - rad }, 52);\n//   // bottom-right corner (0 -> +90)\n//   addArc(pts, r - rad, b - rad, rad, 0, Math.PI / 2, 22);\n\n//   // bottom (right->left)\n//   addLine(pts, pts[pts.length - 1], { x: l + rad, y: b }, 40);\n//   // bottom-left corner (+90 -> 180)\n//   addArc(pts, l + rad, b - rad, rad, Math.PI / 2, Math.PI, 22);\n\n//   // left (bottom->top)\n//   addLine(pts, pts[pts.length - 1], { x: l, y: t + rad }, 52);\n//   // top-left corner (180 -> 270)\n//   addArc(pts, l + rad, t + rad, rad, Math.PI, 3 * Math.PI / 2, 22);\n\n//   // ---- warp(êµ´ê³¡) ----\n//   // ì™¼ìª½ êµ¬ê°„: y 30~72 ì‚¬ì´ì—ì„œ ì•ˆìª½ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” êµ´ê³¡(ì‚¬ì§„ íŠ¸ë™ ì™¼ìª½ ëŠë‚Œ)\n//   // ì˜¤ë¥¸ìª½ êµ¬ê°„: y 22~74 ì‚¬ì´ì—ì„œ ë°”ê¹¥ìœ¼ë¡œ ì‚´ì§ ë¶€í’€ë¦¬ëŠ” êµ´ê³¡\n//   function bump(y, y0, y1) {\n//     if (y <= y0 || y >= y1) return 0;\n//     const u = (y - y0) / (y1 - y0); // 0~1\n//     // ê°€ìš´ë°ê°€ ê°€ì¥ í° ì™„ë§Œí•œ ë´‰ìš°ë¦¬\n//     return Math.sin(Math.PI * u) ** 2;\n//   }\n\n//   const warped = pts.map(p => {\n//     let { x, y } = p;\n\n//     // left edge ê·¼ì²˜ë©´ ì•ˆìª½ìœ¼ë¡œ\n//     if (x <= l + 1.0) {\n//       const k = bump(y, 30, 72);\n//       x = x + 10 * k; // ì•ˆìª½(ì˜¤ë¥¸ìª½)ìœ¼ë¡œ ìµœëŒ€ 10%\n//     }\n\n//     // right edge ê·¼ì²˜ë©´ ë°”ê¹¥ìœ¼ë¡œ ì‚´ì§\n//     if (x >= r - 1.0) {\n//       const k = bump(y, 22, 74);\n//       x = x + 6 * k; // ë°”ê¹¥(ì˜¤ë¥¸ìª½)ìœ¼ë¡œ ìµœëŒ€ 6%\n//     }\n\n//     // í´ë¨í”„\n//     x = Math.max(3, Math.min(97, x));\n//     y = Math.max(3, Math.min(97, y));\n//     return { x, y };\n//   });\n\n//   return warped;\n// }\n\n// const TRACK_POINTS = makeTrackV1();\n// global.set(\"TRACK_POINTS\", TRACK_POINTS);\n\n// // -------------------------\n// // 1) Helper: snap point to nearest track point\n// // -------------------------\n// function dist2(a, b) {\n//   const dx = a.x - b.x, dy = a.y - b.y;\n//   return dx * dx + dy * dy;\n// }\n// function snapToTrack(p) {\n//   let best = TRACK_POINTS[0];\n//   let bestD = 1e18;\n//   for (let i = 0; i < TRACK_POINTS.length; i++) {\n//     const d = dist2(p, TRACK_POINTS[i]);\n//     if (d < bestD) { bestD = d; best = TRACK_POINTS[i]; }\n//   }\n//   return { x: best.x, y: best.y };\n// }\n\n// // -------------------------\n// // 2) AREA_POS (percent coords) + snap\n// // -------------------------\n// let AREA_POS = {\n//   CHARGE: { x: 50, y: 10 }, // ì¶©ì „ì†Œ(ë§¨ ìœ„)\n//   WATER:  { x: 20, y: 38 }, // ì •ìˆ˜ê¸°(ì™¼ìª½)\n//   DROP:   { x: 80, y: 38 }, // í™˜ê²½ì •ë¦¬/ë°˜ë‚©(ì˜¤ë¥¸ìª½)\n//   RES_A:  { x: 28, y: 78 }, // ìœ ì €ê³µê°„1\n//   RES_B:  { x: 50, y: 86 }, // ìœ ì €ê³µê°„2\n//   RES_C:  { x: 72, y: 78 }, // ìœ ì €ê³µê°„3\n// };\n\n// // ì •ë¥˜ì¥ì€ íŠ¸ë™ ìœ„ì— ë”± ë¶™ê²Œ ìŠ¤ëƒ…\n// for (const k of Object.keys(AREA_POS)) {\n//   AREA_POS[k] = snapToTrack(AREA_POS[k]);\n// }\n// global.set(\"AREA_POS\", AREA_POS);\n\n// // -------------------------\n// // 3) Global state init\n// // -------------------------\n// let robots = global.get(\"robots\") || {};\n// let taskQueue = global.get(\"taskQueue\") || [];\n// let events = global.get(\"events\") || [];\n\n// if (!robots[\"agv1\"]) robots[\"agv1\"] = {};\n\n// robots[\"agv1\"] = {\n//   ...(robots[\"agv1\"] || {}),\n//   robot_id: \"agv1\",\n//   state: \"idle\",\n//   task_id: null,\n//   battery: robots[\"agv1\"].battery ?? 100,\n\n//   // âœ… ì‹œì‘ ìœ„ì¹˜: ì¶©ì „ì†Œ (íŠ¸ë™ ìœ„)\n//   area: \"CHARGE\",\n//   pose: { x: AREA_POS.CHARGE.x, y: AREA_POS.CHARGE.y, theta: 0 },\n\n//   error_code: null,\n//   updated_at: Date.now(),\n// };\n\n// global.set(\"robots\", robots);\n// global.set(\"taskQueue\", taskQueue);\n// global.set(\"events\", events);\n\n// node.status({ fill: \"green\", shape: \"dot\", text: \"init ok: TRACK + AREA_POS snapped\" });\n\n// // Firestoreì—ë„ ë°˜ì˜(ë„ˆí¬ /api/robotsê°€ Firestore ë³´ëŠ” êµ¬ì¡°ë¼ì„œ)\n// const db = global.get(\"db\");\n// if (db) {\n//   db.collection(\"robots\").doc(\"agv1\").set(robots[\"agv1\"], { merge: true })\n//     .catch(err => node.error(\"[init robots write] \" + err));\n// }\n\n// return null;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// InitGlobalState (CALIB TRACK_POINTS + AREA_POS by zone-box + agv1 init)\n\n// ======================================================\n// 0) (fallback) Track generator (percent coords 0~100)\n// ======================================================\nfunction addLine(pts, a, b, steps) {\n  for (let i = 1; i <= steps; i++) {\n    const t = i / steps;\n    pts.push({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });\n  }\n}\n\nfunction addArc(pts, cx, cy, r, a0, a1, steps) {\n  for (let i = 1; i <= steps; i++) {\n    const t = i / steps;\n    const a = a0 + (a1 - a0) * t;\n    pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });\n  }\n}\n\n// \"ë‘¥ê·¼ ì‚¬ê° ë£¨í”„\" + ì•½ê°„ êµ´ê³¡\nfunction makeTrackV1() {\n  const l = 16, t = 14, r = 86, b = 86;\n  const rad = 16;\n  const pts = [];\n\n  pts.push({ x: l + rad, y: t });\n\n  addLine(pts, pts[pts.length - 1], { x: r - rad, y: t }, 40);\n  addArc(pts, r - rad, t + rad, rad, -Math.PI / 2, 0, 22);\n\n  addLine(pts, pts[pts.length - 1], { x: r, y: b - rad }, 52);\n  addArc(pts, r - rad, b - rad, rad, 0, Math.PI / 2, 22);\n\n  addLine(pts, pts[pts.length - 1], { x: l + rad, y: b }, 40);\n  addArc(pts, l + rad, b - rad, rad, Math.PI / 2, Math.PI, 22);\n\n  addLine(pts, pts[pts.length - 1], { x: l, y: t + rad }, 52);\n  addArc(pts, l + rad, t + rad, rad, Math.PI, 3 * Math.PI / 2, 22);\n\n  function bump(y, y0, y1) {\n    if (y <= y0 || y >= y1) return 0;\n    const u = (y - y0) / (y1 - y0);\n    return Math.sin(Math.PI * u) ** 2;\n  }\n\n  const warped = pts.map(p => {\n    let { x, y } = p;\n\n    if (x <= l + 1.0) {\n      const k = bump(y, 30, 72);\n      x = x + 10 * k;\n    }\n    if (x >= r - 1.0) {\n      const k = bump(y, 22, 74);\n      x = x + 6 * k;\n    }\n\n    x = Math.max(3, Math.min(97, x));\n    y = Math.max(3, Math.min(97, y));\n    return { x, y };\n  });\n\n  return warped;\n}\n\n// ======================================================\n// 1) Track load: calibration json(dense) ìš°ì„ , ì‹¤íŒ¨ ì‹œ fallback\n// ======================================================\nfunction clamp100(v) {\n  if (!Number.isFinite(v)) return 0;\n  return Math.max(0, Math.min(100, v));\n}\nfunction dist2(a, b) {\n  const dx = a.x - b.x, dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\nfunction normalizeTrack(points) {\n  let arr = Array.isArray(points) ? points : [];\n  arr = arr\n    .filter(p => p && Number.isFinite(p.x) && Number.isFinite(p.y))\n    .map(p => ({ x: clamp100(p.x), y: clamp100(p.y) }));\n\n  if (arr.length < 2) return arr;\n\n  // ìº˜ë¦¬ denseëŠ” ë³´í†µ ë§ˆì§€ë§‰ ì ì´ ì²« ì ê³¼ ê°™ìŒ(ë‹«í˜) -> ì¤‘ë³µ 1ê°œ ì œê±°\n  const first = arr[0];\n  const last = arr[arr.length - 1];\n  if (dist2(first, last) < 0.0001) arr = arr.slice(0, -1);\n\n  return arr;\n}\n\n// NOTE) ì—¬ê¸° ê²½ë¡œë§Œ ë„¤ í™˜ê²½ì— ë§ê²Œ ìˆ˜ì •\n// - ê¶Œì¥: track_agv1.jsonì„ .node-red í´ë”ì— ë‘ê³  ê·¸ íŒŒì¼ ê²½ë¡œë¥¼ ì‚¬ìš©\nconst TRACK_JSON_PATH = \"C:/Users/wp3wk/AppData/Roaming/SPB_Data/.node-red/track_agv1.json\";\n\n// fsëŠ” Function ë…¸ë“œ \"Setup(Modules)\"ì— fs ì¶”ê°€í•´ë‘ë©´ global.get(\"fs\")ë¡œ ì¡í˜.\n// (ì—†ìœ¼ë©´ require ì‹œë„ -> ê·¸ë§ˆì € ë§‰í˜€ìˆìœ¼ë©´ fallback íŠ¸ë™ ì‚¬ìš©)\nlet fs = global.get(\"fs\");\nif (!fs) {\n  try { fs = require(\"fs\"); } catch (e) {}\n}\n\nlet TRACK_POINTS = null;\nlet trackSource = \"fallback(makeTrackV1)\";\n\nif (fs) {\n  try {\n    const raw = fs.readFileSync(TRACK_JSON_PATH, \"utf8\");\n    const obj = JSON.parse(raw);\n\n    // UserApp.vue ì €ì¥ í¬ë§·: { anchors:[], dense:[], saved_at:... }\n    if (Array.isArray(obj?.dense)) {\n      TRACK_POINTS = obj.dense;\n      trackSource = \"calib(json.dense)\";\n    } else if (Array.isArray(obj?.TRACK_POINTS)) {\n      TRACK_POINTS = obj.TRACK_POINTS;\n      trackSource = \"calib(json.TRACK_POINTS)\";\n    } else if (Array.isArray(obj)) {\n      TRACK_POINTS = obj;\n      trackSource = \"calib(json=array)\";\n    }\n  } catch (e) {\n    node.warn(\"[initGlobalState] Failed to load track json. path=\" + TRACK_JSON_PATH + \" err=\" + e);\n  }\n} else {\n  node.warn(\"[initGlobalState] fs not available. Add 'fs' in Function node Setup(Modules) or enable require(). Using fallback track.\");\n}\n\nTRACK_POINTS = normalizeTrack(TRACK_POINTS);\nif (!TRACK_POINTS || TRACK_POINTS.length < 2) {\n  TRACK_POINTS = makeTrackV1();\n  TRACK_POINTS = normalizeTrack(TRACK_POINTS);\n  trackSource = \"fallback(makeTrackV1)\";\n}\n\nglobal.set(\"TRACK_POINTS\", TRACK_POINTS);\n\n// ======================================================\n// 2) Helper: snap point to nearest track point\n// ======================================================\nfunction snapToTrack(p) {\n  let best = TRACK_POINTS[0];\n  let bestD = 1e18;\n  for (let i = 0; i < TRACK_POINTS.length; i++) {\n    const d = dist2(p, TRACK_POINTS[i]);\n    if (d < bestD) { bestD = d; best = TRACK_POINTS[i]; }\n  }\n  return { x: best.x, y: best.y };\n}\n\n// ======================================================\n// 3) AREA_POS: UserApp.vueì˜ zone ë°•ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ \"ë°•ìŠ¤ ì•ˆ íŠ¸ë™ ì \" ì„ íƒ\n// ======================================================\n// UserApp.vue CSS ê¸°ì¤€(í¼ì„¼íŠ¸):\n// .z-charge{ left:40 top:6 width:20 height:12 }\n// .z-water { left:8  top:22 width:22 height:16 }\n// .z-drop  { left:70 top:30 width:22 height:16 }\n// .z-a     { left:10 top:66 width:24 height:18 }\n// .z-b     { left:38 top:74 width:24 height:18 }\n// .z-c     { left:66 top:66 width:24 height:18 }\nconst ZONES = {\n  CHARGE: { left: 40, top:  6, width: 20, height: 12 },\n  WATER:  { left:  8, top: 22, width: 22, height: 16 },\n  DROP:   { left: 70, top: 30, width: 22, height: 16 },\n  RES_A:  { left: 10, top: 66, width: 24, height: 18 },\n  RES_B:  { left: 38, top: 74, width: 24, height: 18 },\n  RES_C:  { left: 66, top: 66, width: 24, height: 18 },\n};\n\nfunction zoneCenter(z) {\n  return { x: z.left + z.width / 2, y: z.top + z.height / 2 };\n}\n\nfunction pickStationOnTrackByZone(zone) {\n  const x0 = zone.left, x1 = zone.left + zone.width;\n  const y0 = zone.top,  y1 = zone.top + zone.height;\n  const c = zoneCenter(zone);\n\n  // 1) ë°•ìŠ¤ ì•ˆì— ë“¤ì–´ì˜¤ëŠ” íŠ¸ë™ ì  í›„ë³´\n  let best = null;\n  let bestD = 1e18;\n  for (const p of TRACK_POINTS) {\n    if (p.x < x0 || p.x > x1 || p.y < y0 || p.y > y1) continue;\n    const d = dist2(c, p);\n    if (d < bestD) { bestD = d; best = p; }\n  }\n\n  // 2) ë°•ìŠ¤ ì•ˆ í›„ë³´ê°€ ì—†ìœ¼ë©´: centerë¥¼ íŠ¸ë™ì— snap\n  if (!best) return snapToTrack(c);\n  return { x: best.x, y: best.y };\n}\n\nlet AREA_POS = {\n  CHARGE: pickStationOnTrackByZone(ZONES.CHARGE),\n  WATER:  pickStationOnTrackByZone(ZONES.WATER),\n  DROP:   pickStationOnTrackByZone(ZONES.DROP),\n  RES_A:  pickStationOnTrackByZone(ZONES.RES_A),\n  RES_B:  pickStationOnTrackByZone(ZONES.RES_B),\n  RES_C:  pickStationOnTrackByZone(ZONES.RES_C),\n};\n\nglobal.set(\"AREA_POS\", AREA_POS);\n\n// ======================================================\n// 4) Global state init\n// ======================================================\nlet robots = global.get(\"robots\") || {};\nlet taskQueue = global.get(\"taskQueue\") || [];\nlet events = global.get(\"events\") || [];\n\nif (!robots[\"agv1\"]) robots[\"agv1\"] = {};\n\nrobots[\"agv1\"] = {\n  ...(robots[\"agv1\"] || {}),\n  robot_id: \"agv1\",\n  state: \"idle\",\n  task_id: null,\n  battery: robots[\"agv1\"].battery ?? 100,\n\n  // âœ… ì‹œì‘ ìœ„ì¹˜: ì¶©ì „ì†Œ (íŠ¸ë™ ìœ„)\n  area: \"CHARGE\",\n  pose: { x: AREA_POS.CHARGE.x, y: AREA_POS.CHARGE.y, theta: 0 },\n\n  error_code: null,\n  updated_at: Date.now(),\n};\n\nglobal.set(\"robots\", robots);\nglobal.set(\"taskQueue\", taskQueue);\nglobal.set(\"events\", events);\n\nnode.status({ fill: \"green\", shape: \"dot\", text: `init ok: ${trackSource} + AREA_POS by zones` });\n\n// Firestoreì—ë„ ë°˜ì˜\nconst db = global.get(\"db\");\nif (db) {\n  db.collection(\"robots\").doc(\"agv1\").set(robots[\"agv1\"], { merge: true })\n    .catch(err => node.error(\"[init robots write] \" + err));\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "5683f1a5e869fec8",
        "type": "mqtt in",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "robot/agv1/task",
        "qos": "2",
        "datatype": "utf8",
        "broker": "3c16a07776b27396",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 360,
        "y": 1540,
        "wires": [
            [
                "4319d8f20df90726",
                "a50e6fc76e6e8f77"
            ]
        ]
    },
    {
        "id": "4319d8f20df90726",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "simulateAGV",
        "func": "// // simulateAGV (UI %ì¢Œí‘œ í†µì¼ + waypoint ë™ì„  ë²„ì „)\n// // input: robot/agv1/task (msg.payload = task JSON)\n// // output1: running stream (array of msgs w/ msg.delay)\n// // output2: done + idle (2 msgs w/ msg.delay)\n\n// let task;\n// try {\n//   task = JSON.parse(msg.payload || \"{}\");\n// } catch (e) {\n//   node.error(\"Invalid task JSON in simulateAGV\", msg);\n//   return null;\n// }\n\n// const robotId = \"agv1\";\n\n// // -------------------------\n// // 0) AREA_POS: UI percent coords (0~100)\n// // -------------------------\n// const AREA_POS = global.get(\"AREA_POS\") || {\n//   CHARGE: { x: 50, y: 10 },\n//   WATER:  { x: 18, y: 28 },\n//   DROP:   { x: 82, y: 42 },\n//   RES_A:  { x: 20, y: 70 },\n//   RES_B:  { x: 42, y: 82 },\n//   RES_C:  { x: 70, y: 82 },\n// };\n\n// // -------------------------\n// // 1) context state (battery/area/pose)\n// // -------------------------\n// let battery = context.get(\"battery\") ?? 80;\n// let area = String(context.get(\"area\") || \"CHARGE\").toUpperCase();\n// let pose = context.get(\"pose\") || null;\n\n// // ë°°í„°ë¦¬ ì‚´ì§ ê¹ê¸°\n// battery = Math.max(0, battery - 1);\n// context.set(\"battery\", battery);\n\n// // âœ… êµ¬ë²„ì „ ê·¸ë¦¬ë“œ ì¢Œí‘œê°€ ë‚¨ì•„ìˆëŠ” ê²½ìš° ìë™ ë¦¬ì…‹\n// function looksLikeOldGridPose(p) {\n//   // ì˜ˆì „ ì¢Œí‘œëŠ” ëŒ€ê°œ 0~12 ê°™ì€ ì‘ì€ ê°’\n//   return p && typeof p.x === \"number\" && typeof p.y === \"number\" && p.x <= 15 && p.y <= 15;\n// }\n// if (!pose || looksLikeOldGridPose(pose)) {\n//   const p0 = AREA_POS[area] || AREA_POS.CHARGE;\n//   pose = { x: p0.x, y: p0.y, theta: 0 };\n//   context.set(\"pose\", pose);\n// }\n\n// // areaë„ êµ¬ë²„ì „ ê°’ì¼ ìˆ˜ ìˆì–´ ë°©ì–´ (BASE/DOCK/USER1/USER2 ë“±)\n// const legacyAreaMap = { BASE: \"CHARGE\", DOCK: \"CHARGE\", USER1: \"RES_A\", USER2: \"RES_B\" };\n// if (legacyAreaMap[area]) {\n//   area = legacyAreaMap[area];\n//   context.set(\"area\", area);\n// }\n\n// // -------------------------\n// // 2) waypoint plan (ì‹œì—° ë™ì„ ìš©)\n// // -------------------------\n// function normTargetArea(raw) {\n//   const s = String(raw || \"\").toUpperCase();\n//   const map = { USER1: \"RES_A\", USER2: \"RES_B\", USER3: \"RES_C\", BASE: \"CHARGE\", HOME: \"CHARGE\", DOCK: \"CHARGE\" };\n//   if (map[s]) return map[s];\n//   if ([\"CHARGE\", \"WATER\", \"DROP\", \"RES_A\", \"RES_B\", \"RES_C\"].includes(s)) return s;\n//   return \"RES_B\";\n// }\n// const userArea = normTargetArea(task.target_area);\n\n// // typeë³„ ë™ì„ \n// // - deliver_water: (í˜„ì¬) -> WATER -> user -> CHARGE\n// // - collect_cup / collect_laundry: (í˜„ì¬) -> user -> DROP -> CHARGE\n// let waypoints = [];\n// if (task.type === \"deliver_water\") {\n//   waypoints = [\"WATER\", userArea, \"CHARGE\"];\n// } else if (task.type === \"collect_cup\" || task.type === \"collect_laundry\") {\n//   waypoints = [userArea, \"DROP\", \"CHARGE\"];\n// } else {\n//   // unknown: ê·¸ëƒ¥ targetë§Œ ê°”ë‹¤ê°€ ì¶©ì „ì†Œ ë³µê·€\n//   waypoints = [userArea, \"CHARGE\"];\n// }\n\n// // í˜„ì¬ areaê°€ waypoint ì²«ë²ˆì§¸ì™€ ê°™ìœ¼ë©´ ì¤‘ë³µ ì œê±°\n// waypoints = waypoints.filter((w, i) => i === 0 || w !== waypoints[i - 1]);\n\n// // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì²« waypointê¹Œì§€ë„ ì´ë™í•´ì•¼ í•˜ë‹ˆ ì‹œì‘ì  í¬í•¨í•œ point list ë§Œë“¤ê¸°\n// function getPos(areaCode, fallbackPos) {\n//   return AREA_POS[areaCode] || fallbackPos;\n// }\n\n// // -------------------------\n// // 3) duration (expected ê¸°ë°˜ + ì§€í„°) + êµ¬ê°„ë³„ ë¶„ë°°\n// // -------------------------\n// const base = Number(task.expected_duration_ms) || 12000;\n// const jitter = 0.85 + Math.random() * 0.30; // 0.85~1.15\n// const TOTAL_MS = Math.round(base * jitter);\n\n// const STEP_MS = 200;\n\n// function dist(a, b) {\n//   const dx = (b.x - a.x);\n//   const dy = (b.y - a.y);\n//   return Math.sqrt(dx * dx + dy * dy);\n// }\n\n// let curPos = { x: pose.x, y: pose.y };\n// let segmentPos = [];\n// for (const wp of waypoints) {\n//   segmentPos.push(getPos(wp, curPos));\n// }\n// const segDists = [];\n// let totalDist = 0;\n// let prev = curPos;\n// for (const p of segmentPos) {\n//   const d = dist(prev, p);\n//   segDists.push(d);\n//   totalDist += d;\n//   prev = p;\n// }\n// if (totalDist <= 0) totalDist = segDists.length; // ëª¨ë‘ 0ì´ë©´ ê· ë“±ë¶„ë°°\n\n// let segDur = segDists.map(d => Math.max(STEP_MS, Math.round(TOTAL_MS * (d / totalDist))));\n// let sumDur = segDur.reduce((a, b) => a + b, 0);\n// // í•©ì´ TOTAL_MSë‘ ì•ˆë§ìœ¼ë©´ ë§ˆì§€ë§‰ì— ë³´ì •\n// segDur[segDur.length - 1] = Math.max(STEP_MS, segDur[segDur.length - 1] - (sumDur - TOTAL_MS));\n\n// // -------------------------\n// // 4) running stream ìƒì„±\n// // -------------------------\n// function heading(from, to) {\n//   return Math.atan2((to.y - from.y), (to.x - from.x));\n// }\n// function lerp(a, b, t) {\n//   return a + (b - a) * t;\n// }\n\n// const msgsRunning = [];\n// let delayAcc = 0;\n\n// let curArea = area;\n// let fromPos = curPos;\n\n// for (let s = 0; s < segmentPos.length; s++) {\n//   const toPos = segmentPos[s];\n//   const target = waypoints[s];\n//   const dur = segDur[s];\n\n//   const steps = Math.max(1, Math.floor(dur / STEP_MS));\n\n//   for (let i = 0; i <= steps; i++) {\n//     const t = i / steps;\n//     const x = lerp(fromPos.x, toPos.x, t);\n//     const y = lerp(fromPos.y, toPos.y, t);\n//     const theta = heading({ x, y }, toPos);\n\n//     const runningStatus = {\n//       robot_id: robotId,\n//       state: \"running\",\n//       task_id: task.task_id || null,\n//       battery,\n//       area: curArea,          // í˜„ì¬ êµ¬ì—­(í° ì˜ë¯¸) - êµ¬ê°„ ì‹œì‘ êµ¬ì—­\n//       target_area: target,    // ì§€ê¸ˆ í–¥í•˜ëŠ” ëª©ì ì§€\n//       error_code: null,\n//       pose: { x, y, theta },  // âœ… UI% ì¢Œí‘œ\n//       updated_at: Date.now(),\n//     };\n\n//     msgsRunning.push({\n//       topic: `robot/${robotId}/status`,\n//       payload: JSON.stringify(runningStatus),\n//       delay: delayAcc + i * STEP_MS,\n//     });\n//   }\n\n//   // êµ¬ê°„ ì™„ë£Œ â†’ í˜„ì¬ êµ¬ì—­ ê°±ì‹ \n//   delayAcc += dur;\n//   fromPos = toPos;\n//   curArea = target;\n// }\n\n// // ì™„ë£Œ ìœ„ì¹˜ë¥¼ contextì— ì €ì¥ (ëŒ€ë¶€ë¶„ CHARGEë¡œ ëë‚¨)\n// pose = { x: fromPos.x, y: fromPos.y, theta: 0 };\n// context.set(\"pose\", pose);\n// context.set(\"area\", curArea);\n\n// // -------------------------\n// // 5) done + idle\n// // -------------------------\n// const doneStatus = {\n//   robot_id: robotId,\n//   state: \"done\",\n//   task_id: task.task_id || null,\n//   battery,\n//   area: curArea,\n//   target_area: null,\n//   error_code: null,\n//   pose,\n//   updated_at: Date.now(),\n// };\n\n// const idleStatus = {\n//   robot_id: robotId,\n//   state: \"idle\",\n//   task_id: null,\n//   battery,\n//   area: curArea,\n//   target_area: null,\n//   error_code: null,\n//   pose,\n//   updated_at: Date.now(),\n// };\n\n// const msgDone = {\n//   topic: `robot/${robotId}/status`,\n//   payload: JSON.stringify(doneStatus),\n//   delay: delayAcc,\n// };\n\n// const msgIdle = {\n//   topic: `robot/${robotId}/status`,\n//   payload: JSON.stringify(idleStatus),\n//   delay: delayAcc + 300,\n// };\n\n// return [msgsRunning, [msgDone, msgIdle]];\n\n\n\n\n// simulateAGV (TRACK ê¸°ë°˜ ì£¼í–‰ ë²„ì „)\n// output1: running stream(msg.delay ì‚¬ìš©), output2: done + idle\n\n// let task;\n// try {\n//   task = JSON.parse(msg.payload || \"{}\");\n// } catch (e) {\n//   node.error(\"Invalid task JSON in simulateAGV\", msg);\n//   return null;\n// }\n\n// const robotId = \"agv1\";\n// const STEP_MS = 200;\n\n// const AREA_POS = global.get(\"AREA_POS\") || {};\n// const TRACK = global.get(\"TRACK_POINTS\") || [];\n\n// if (!TRACK.length) {\n//   node.error(\"TRACK_POINTS not found. Run InitGlobalState first.\", msg);\n//   return null;\n// }\n\n// // -------------------------\n// // context state\n// // -------------------------\n// let battery = context.get(\"battery\") ?? 80;\n// let area = String(context.get(\"area\") || \"CHARGE\").toUpperCase();\n// let pose = context.get(\"pose\") || null;\n\n// // ë°°í„°ë¦¬ ì‚´ì§ ê¹ê¸°\n// battery = Math.max(0, battery - 1);\n// context.set(\"battery\", battery);\n\n// // êµ¬ë²„ì „ grid pose ë°©ì–´\n// function looksLikeOldGridPose(p) {\n//   return p && typeof p.x === \"number\" && typeof p.y === \"number\" && p.x <= 15 && p.y <= 15;\n// }\n// if (!pose || looksLikeOldGridPose(pose)) {\n//   const p0 = AREA_POS[area] || AREA_POS.CHARGE;\n//   pose = { x: p0.x, y: p0.y, theta: 0 };\n//   context.set(\"pose\", pose);\n// }\n\n// // area legacy ë°©ì–´\n// const legacyAreaMap = { BASE: \"CHARGE\", DOCK: \"CHARGE\", USER1: \"RES_A\", USER2: \"RES_B\", HOME: \"CHARGE\" };\n// if (legacyAreaMap[area]) {\n//   area = legacyAreaMap[area];\n//   context.set(\"area\", area);\n// }\n\n// // -------------------------\n// // helpers\n// // -------------------------\n// function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }\n// function heading(from, to) { return Math.atan2(to.y - from.y, to.x - from.x); }\n\n// function nearestIdx(p) {\n//   let best = 0;\n//   let bestD = 1e18;\n//   for (let i = 0; i < TRACK.length; i++) {\n//     const d = (TRACK[i].x - p.x) ** 2 + (TRACK[i].y - p.y) ** 2;\n//     if (d < bestD) { bestD = d; best = i; }\n//   }\n//   return best;\n// }\n\n// function sliceLoop(i0, i1, dir) {\n//   const n = TRACK.length;\n//   const out = [TRACK[i0]];\n//   let i = i0;\n//   while (i !== i1) {\n//     i = (i + dir + n) % n;\n//     out.push(TRACK[i]);\n//     if (out.length > n + 5) break; // safety\n//   }\n//   return out;\n// }\n\n// function pathLen(path) {\n//   let s = 0;\n//   for (let i = 1; i < path.length; i++) s += dist(path[i - 1], path[i]);\n//   return s;\n// }\n\n// function bestPathOnLoop(p0, p1) {\n//   const i0 = nearestIdx(p0);\n//   const i1 = nearestIdx(p1);\n//   const fwd = sliceLoop(i0, i1, +1);\n//   const bwd = sliceLoop(i0, i1, -1);\n//   return (pathLen(fwd) <= pathLen(bwd)) ? fwd : bwd;\n// }\n\n// // ê±°ë¦¬ê¸°ë°˜ resample (steps+1ê°œ)\n// function resample(path, count) {\n//   if (!path.length) return [];\n//   if (path.length === 1) return Array(count).fill({ ...path[0] });\n\n//   // ëˆ„ì ê±°ë¦¬\n//   const seg = [];\n//   let total = 0;\n//   for (let i = 1; i < path.length; i++) {\n//     const d = dist(path[i - 1], path[i]);\n//     seg.push(d);\n//     total += d;\n//   }\n//   if (total <= 1e-9) return Array(count).fill({ ...path[0] });\n\n//   const out = [];\n//   let acc = 0;\n//   let si = 0;\n\n//   out.push({ ...path[0] });\n\n//   for (let k = 1; k < count; k++) {\n//     const target = (total * k) / (count - 1);\n//     while (si < seg.length && acc + seg[si] < target) {\n//       acc += seg[si];\n//       si++;\n//     }\n//     if (si >= seg.length) { out.push({ ...path[path.length - 1] }); continue; }\n\n//     const t = (target - acc) / (seg[si] || 1);\n//     const a = path[si];\n//     const b = path[si + 1] || path[si];\n//     out.push({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });\n//   }\n//   return out;\n// }\n\n// // target_area ì •ê·œí™”\n// function normTargetArea(raw) {\n//   const s = String(raw || \"\").toUpperCase();\n//   const map = { USER1: \"RES_A\", USER2: \"RES_B\", USER3: \"RES_C\", BASE: \"CHARGE\", HOME: \"CHARGE\", DOCK: \"CHARGE\" };\n//   if (map[s]) return map[s];\n//   if ([\"CHARGE\", \"WATER\", \"DROP\", \"RES_A\", \"RES_B\", \"RES_C\"].includes(s)) return s;\n//   return \"RES_B\";\n// }\n// const userArea = normTargetArea(task.target_area);\n\n// // -------------------------\n// // waypoint plan\n// // -------------------------\n// let waypoints = [];\n// if (task.type === \"deliver_water\") {\n//   waypoints = [\"WATER\", userArea, \"CHARGE\"];\n// } else if (task.type === \"collect_cup\" || task.type === \"collect_laundry\") {\n//   waypoints = [userArea, \"DROP\", \"CHARGE\"];\n// } else {\n//   waypoints = [userArea, \"CHARGE\"];\n// }\n\n// // -------------------------\n// // duration (expected ê¸°ë°˜ + ì§€í„°) + segment ë¶„ë°°\n// // -------------------------\n// const base = Number(task.expected_duration_ms) || 20000;\n// const jitter = 0.90 + Math.random() * 0.20; // 0.9~1.1 (ë„ˆë¬´ í”ë“¤ë¦¬ë©´ ì˜ìƒì—ì„œ ì–´ìƒ‰í•´ì„œ ì‚´ì§ë§Œ)\n// const TOTAL_MS = Math.round(base * jitter);\n\n// // segmentë³„ path/ê±°ë¦¬ ê³„ì‚°\n// let fromPos = { x: pose.x, y: pose.y };\n// let segPaths = [];\n// let segDists = [];\n// let totalDist = 0;\n\n// for (const wp of waypoints) {\n//   const toPos = AREA_POS[wp] || fromPos;\n//   const p = bestPathOnLoop(fromPos, toPos);\n//   const d = pathLen(p);\n//   segPaths.push({ target: wp, path: p, toPos });\n//   segDists.push(d);\n//   totalDist += d;\n//   fromPos = toPos;\n// }\n// if (totalDist <= 1e-9) totalDist = segDists.length;\n\n// // segment duration ë°°ë¶„\n// let segDur = segDists.map(d => Math.max(STEP_MS, Math.round(TOTAL_MS * (d / totalDist))));\n// let sumDur = segDur.reduce((a, b) => a + b, 0);\n// segDur[segDur.length - 1] = Math.max(STEP_MS, segDur[segDur.length - 1] - (sumDur - TOTAL_MS));\n\n// // -------------------------\n// // running stream ìƒì„± (íŠ¸ë™ ìœ„)\n// // -------------------------\n// const msgsRunning = [];\n// let delayAcc = 0;\n// let curArea = area; // ë§ˆì§€ë§‰ ë„ì°© ì •ë¥˜ì¥(ì‹œì‘ì€ CHARGE)\n// const t0 = Date.now();\n\n// let curPos2 = { x: pose.x, y: pose.y };\n\n// for (let s = 0; s < segPaths.length; s++) {\n//   const { target, path, toPos } = segPaths[s];\n//   const dur = segDur[s];\n\n//   const steps = Math.max(1, Math.floor(dur / STEP_MS));\n//   let samples = resample(path, steps + 1);\n\n//   // ë‹¤ìŒ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘ê³¼ ì¤‘ë³µ ë°©ì§€(ì²« ì  ì œê±°)\n//   if (s > 0 && samples.length > 0) samples = samples.slice(1);\n\n//   for (let i = 0; i < samples.length; i++) {\n//     const p = samples[i];\n//     const next = samples[Math.min(i + 1, samples.length - 1)];\n//     const theta = heading(p, next);\n\n//     const dly = delayAcc + i * STEP_MS;\n\n//     msgsRunning.push({\n//       topic: `robot/${robotId}/status`,\n//       payload: JSON.stringify({\n//         robot_id: robotId,\n//         state: \"running\",\n//         task_id: task.task_id || null,\n//         battery,\n//         area: curArea,       // â­ â€œë§ˆì§€ë§‰ ë„ì°© ì •ë¥˜ì¥â€\n//         target_area: target, // â­ â€œì§€ê¸ˆ ê°€ëŠ” ì •ë¥˜ì¥â€\n//         error_code: null,\n//         pose: { x: p.x, y: p.y, theta },\n//         updated_at: t0 + dly,\n//       }),\n//       delay: dly,\n//     });\n//   }\n\n//   // ì„¸ê·¸ë¨¼íŠ¸ ë â†’ ì •ë¥˜ì¥ ë„ì°©\n//   delayAcc += dur;\n//   curArea = target;\n//   curPos2 = toPos;\n// }\n\n// // ì™„ë£Œ ìœ„ì¹˜ ì €ì¥(ëŒ€ë¶€ë¶„ CHARGE)\n// context.set(\"pose\", { x: curPos2.x, y: curPos2.y, theta: 0 });\n// context.set(\"area\", curArea);\n\n// // -------------------------\n// // done + idle\n// // -------------------------\n// const doneStatus = {\n//   robot_id: robotId,\n//   state: \"done\",\n//   task_id: task.task_id || null,\n//   battery,\n//   area: curArea,\n//   target_area: null,\n//   error_code: null,\n//   pose: { x: curPos2.x, y: curPos2.y, theta: 0 },\n//   updated_at: t0 + delayAcc,\n// };\n\n// const idleStatus = {\n//   ...doneStatus,\n//   state: \"idle\",\n//   task_id: null,\n//   updated_at: t0 + delayAcc + 300,\n// };\n\n// return [\n//   msgsRunning,\n//   [\n//     { topic: `robot/${robotId}/status`, payload: JSON.stringify(doneStatus), delay: delayAcc },\n//     { topic: `robot/${robotId}/status`, payload: JSON.stringify(idleStatus), delay: delayAcc + 300 },\n//   ],\n// ];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet task;\ntry {\n  task = JSON.parse(msg.payload || \"{}\");\n} catch (e) {\n  node.error(\"Invalid task JSON in simulateAGV\", msg);\n  return null;\n}\n\nconst robotId = \"agv1\";\nconst STEP_MS = 200;\n\nconst AREA_POS = global.get(\"AREA_POS\") || {};\nconst RAW_TRACK = global.get(\"TRACK_POINTS\") || [];\n\n// -------------------------\n// âœ… NEW) Track normalize (calib dense often has last==first)\n// -------------------------\nfunction clamp100(v) {\n  if (!Number.isFinite(v)) return 0;\n  return Math.max(0, Math.min(100, v));\n}\nfunction dist2(a, b) {\n  const dx = a.x - b.x, dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\nfunction normalizeTrack(points) {\n  let arr = Array.isArray(points) ? points : [];\n  arr = arr\n    .filter(p => p && Number.isFinite(p.x) && Number.isFinite(p.y))\n    .map(p => ({ x: clamp100(p.x), y: clamp100(p.y) }));\n\n  if (arr.length < 2) return arr;\n\n  // (1) ë§ˆì§€ë§‰ ì ì´ ì²« ì ê³¼ ê°™ìœ¼ë©´ ì œê±°\n  if (dist2(arr[0], arr[arr.length - 1]) < 0.0001) {\n    arr = arr.slice(0, -1);\n  }\n\n  // (2) ì—°ì† ì¤‘ë³µë„ ì œê±° (í˜¹ì‹œ ëª¨ë¥¼ ì•ˆì „ì¥ì¹˜)\n  const out = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    if (dist2(arr[i], out[out.length - 1]) < 0.0001) continue;\n    out.push(arr[i]);\n  }\n  return out;\n}\n\nconst TRACK = normalizeTrack(RAW_TRACK);\n\nif (!TRACK.length) {\n  node.error(\"TRACK_POINTS not found. Run InitGlobalState first.\", msg);\n  return null;\n}\n\n// -------------------------\n// context state\n// -------------------------\nlet battery = context.get(\"battery\") ?? 80;\nlet area = String(context.get(\"area\") || \"CHARGE\").toUpperCase();\nlet pose = context.get(\"pose\") || null;\n\n// ë°°í„°ë¦¬ ì‚´ì§ ê¹ê¸°\nbattery = Math.max(0, battery - 1);\ncontext.set(\"battery\", battery);\n\n// -------------------------\n// helpers\n// -------------------------\nfunction dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }\nfunction heading(from, to) { return Math.atan2(to.y - from.y, to.x - from.x); }\n\nfunction nearestIdx(p) {\n  let best = 0;\n  let bestD = 1e18;\n  for (let i = 0; i < TRACK.length; i++) {\n    const d = (TRACK[i].x - p.x) ** 2 + (TRACK[i].y - p.y) ** 2;\n    if (d < bestD) { bestD = d; best = i; }\n  }\n  return best;\n}\n\n// âœ… NEW) snapToTrack: AREA_POS ëˆ„ë½/pose ì´ìƒ ì‹œ ì•ˆì „í•˜ê²Œ íŠ¸ë™ ìœ„ë¡œ ì˜¬ë¦¬ê¸°\nfunction snapToTrack(p) {\n  const i = nearestIdx(p);\n  const q = TRACK[i] || TRACK[0];\n  return { x: q.x, y: q.y };\n}\n\n// âœ… NEW) pose/AREA_POS ë°©ì–´ ê°•í™”\nfunction looksLikeOldGridPose(p) {\n  return p && typeof p.x === \"number\" && typeof p.y === \"number\" && p.x <= 15 && p.y <= 15;\n}\nif (!pose || looksLikeOldGridPose(pose)) {\n  const p0 = AREA_POS[area] || AREA_POS.CHARGE || TRACK[0];\n  pose = { x: p0.x, y: p0.y, theta: 0 };\n  // í˜¹ì‹œ AREA_POSê°€ íŠ¸ë™ ë°–ì´ë©´ íŠ¸ë™ìœ¼ë¡œ ìŠ¤ëƒ…\n  const sp = snapToTrack(pose);\n  pose = { x: sp.x, y: sp.y, theta: 0 };\n  context.set(\"pose\", pose);\n}\n\n// area legacy ë°©ì–´\nconst legacyAreaMap = { BASE: \"CHARGE\", DOCK: \"CHARGE\", USER1: \"RES_A\", USER2: \"RES_B\", HOME: \"CHARGE\" };\nif (legacyAreaMap[area]) {\n  area = legacyAreaMap[area];\n  context.set(\"area\", area);\n}\n\nfunction sliceLoop(i0, i1, dir) {\n  const n = TRACK.length;\n  const out = [TRACK[i0]];\n  let i = i0;\n  while (i !== i1) {\n    i = (i + dir + n) % n;\n    out.push(TRACK[i]);\n    if (out.length > n + 5) break; // safety\n  }\n  return out;\n}\n\nfunction pathLen(path) {\n  let s = 0;\n  for (let i = 1; i < path.length; i++) s += dist(path[i - 1], path[i]);\n  return s;\n}\n\nfunction bestPathOnLoop(p0, p1) {\n  // âœ… NEW) ì‹œì‘/ë„ì°©ë„ íŠ¸ë™ìœ¼ë¡œ ìŠ¤ëƒ…í•´ì„œ ë£¨í”„ ì¸ë±ìŠ¤ ì•ˆì •í™”\n  const sp0 = snapToTrack(p0);\n  const sp1 = snapToTrack(p1);\n\n  const i0 = nearestIdx(sp0);\n  const i1 = nearestIdx(sp1);\n\n  const fwd = sliceLoop(i0, i1, +1);\n  const bwd = sliceLoop(i0, i1, -1);\n  return (pathLen(fwd) <= pathLen(bwd)) ? fwd : bwd;\n}\n\n// ê±°ë¦¬ê¸°ë°˜ resample (steps+1ê°œ)\nfunction resample(path, count) {\n  if (!path.length) return [];\n  if (path.length === 1) return Array(count).fill({ ...path[0] });\n\n  const seg = [];\n  let total = 0;\n  for (let i = 1; i < path.length; i++) {\n    const d = dist(path[i - 1], path[i]);\n    seg.push(d);\n    total += d;\n  }\n  if (total <= 1e-9) return Array(count).fill({ ...path[0] });\n\n  const out = [];\n  let acc = 0;\n  let si = 0;\n\n  out.push({ ...path[0] });\n\n  for (let k = 1; k < count; k++) {\n    const target = (total * k) / (count - 1);\n    while (si < seg.length && acc + seg[si] < target) {\n      acc += seg[si];\n      si++;\n    }\n    if (si >= seg.length) { out.push({ ...path[path.length - 1] }); continue; }\n\n    const t = (target - acc) / (seg[si] || 1);\n    const a = path[si];\n    const b = path[si + 1] || path[si];\n    out.push({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });\n  }\n  return out;\n}\n\n// target_area ì •ê·œí™”\nfunction normTargetArea(raw) {\n  const s = String(raw || \"\").toUpperCase();\n  const map = { USER1: \"RES_A\", USER2: \"RES_B\", USER3: \"RES_C\", BASE: \"CHARGE\", HOME: \"CHARGE\", DOCK: \"CHARGE\" };\n  if (map[s]) return map[s];\n  if ([\"CHARGE\", \"WATER\", \"DROP\", \"RES_A\", \"RES_B\", \"RES_C\"].includes(s)) return s;\n  return \"RES_B\";\n}\nconst userArea = normTargetArea(task.target_area);\n\n// -------------------------\n// waypoint plan\n// -------------------------\nlet waypoints = [];\nif (task.type === \"deliver_water\") {\n  waypoints = [\"WATER\", userArea, \"CHARGE\"];\n} else if (task.type === \"collect_cup\" || task.type === \"collect_laundry\") {\n  waypoints = [userArea, \"DROP\", \"CHARGE\"];\n} else {\n  waypoints = [userArea, \"CHARGE\"];\n}\n\n// -------------------------\n// duration (expected ê¸°ë°˜ + ì§€í„°) + segment ë¶„ë°°\n// -------------------------\nconst base = Number(task.expected_duration_ms) || 20000;\nconst jitter = 0.90 + Math.random() * 0.20; // 0.9~1.1\nconst TOTAL_MS = Math.round(base * jitter);\n\n// segmentë³„ path/ê±°ë¦¬ ê³„ì‚°\nlet fromPos = { x: pose.x, y: pose.y };\nlet segPaths = [];\nlet segDists = [];\nlet totalDist = 0;\n\nfor (const wp of waypoints) {\n  // âœ… NEW) AREA_POSê°€ ì—†ìœ¼ë©´ fromPos ê¸°ì¤€ ìŠ¤ëƒ…(ì•ˆ ì£½ê²Œ)\n  const toPosRaw = AREA_POS[wp] || fromPos;\n  const toPos = snapToTrack(toPosRaw);\n\n  const p = bestPathOnLoop(fromPos, toPos);\n  const d = pathLen(p);\n\n  segPaths.push({ target: wp, path: p, toPos });\n  segDists.push(d);\n  totalDist += d;\n  fromPos = toPos;\n}\nif (totalDist <= 1e-9) totalDist = segDists.length;\n\n// segment duration ë°°ë¶„\nlet segDur = segDists.map(d => Math.max(STEP_MS, Math.round(TOTAL_MS * (d / totalDist))));\nlet sumDur = segDur.reduce((a, b) => a + b, 0);\nsegDur[segDur.length - 1] = Math.max(STEP_MS, segDur[segDur.length - 1] - (sumDur - TOTAL_MS));\n\n// -------------------------\n// running stream ìƒì„± (íŠ¸ë™ ìœ„)\n// -------------------------\nconst msgsRunning = [];\nlet delayAcc = 0;\nlet curArea = area; // ë§ˆì§€ë§‰ ë„ì°© ì •ë¥˜ì¥\nconst t0 = Date.now();\n\nlet curPos2 = { x: pose.x, y: pose.y };\n\nfor (let s = 0; s < segPaths.length; s++) {\n  const { target, path, toPos } = segPaths[s];\n  const dur = segDur[s];\n\n  const steps = Math.max(1, Math.floor(dur / STEP_MS));\n  let samples = resample(path, steps + 1);\n\n  // ë‹¤ìŒ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘ê³¼ ì¤‘ë³µ ë°©ì§€(ì²« ì  ì œê±°)\n  if (s > 0 && samples.length > 0) samples = samples.slice(1);\n\n  for (let i = 0; i < samples.length; i++) {\n    const p = samples[i];\n    const next = samples[Math.min(i + 1, samples.length - 1)];\n    const theta = heading(p, next);\n\n    const dly = delayAcc + i * STEP_MS;\n\n    msgsRunning.push({\n      topic: `robot/${robotId}/status`,\n      payload: JSON.stringify({\n        robot_id: robotId,\n        state: \"running\",\n        task_id: task.task_id || null,\n        battery,\n        area: curArea,\n        target_area: target,\n        error_code: null,\n        pose: { x: p.x, y: p.y, theta },\n        updated_at: t0 + dly,\n      }),\n      delay: dly,\n    });\n  }\n\n  // ì„¸ê·¸ë¨¼íŠ¸ ë â†’ ì •ë¥˜ì¥ ë„ì°©\n  delayAcc += dur;\n  curArea = target;\n  curPos2 = toPos;\n}\n\n// ì™„ë£Œ ìœ„ì¹˜ ì €ì¥\ncontext.set(\"pose\", { x: curPos2.x, y: curPos2.y, theta: 0 });\ncontext.set(\"area\", curArea);\n\n// -------------------------\n// done + idle\n// -------------------------\nconst doneStatus = {\n  robot_id: robotId,\n  state: \"done\",\n  task_id: task.task_id || null,\n  battery,\n  area: curArea,\n  target_area: null,\n  error_code: null,\n  pose: { x: curPos2.x, y: curPos2.y, theta: 0 },\n  updated_at: t0 + delayAcc,\n};\n\nconst idleStatus = {\n  ...doneStatus,\n  state: \"idle\",\n  task_id: null,\n  updated_at: t0 + delayAcc + 300,\n};\n\nreturn [\n  msgsRunning,\n  [\n    { topic: `robot/${robotId}/status`, payload: JSON.stringify(doneStatus), delay: delayAcc },\n    { topic: `robot/${robotId}/status`, payload: JSON.stringify(idleStatus), delay: delayAcc + 300 },\n  ],\n];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 1540,
        "wires": [
            [
                "c892835546595db4"
            ],
            [
                "c892835546595db4"
            ]
        ]
    },
    {
        "id": "e5f2fa78b4c8f5b4",
        "type": "mqtt out",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3c16a07776b27396",
        "x": 1470,
        "y": 1480,
        "wires": []
    },
    {
        "id": "5462d48ba72465a3",
        "type": "mqtt out",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3c16a07776b27396",
        "x": 1470,
        "y": 1620,
        "wires": []
    },
    {
        "id": "c892835546595db4",
        "type": "delay",
        "z": "49f8711fc297a8c1",
        "name": "",
        "pauseType": "delayv",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1060,
        "y": 1620,
        "wires": [
            [
                "5462d48ba72465a3",
                "d79424313dccb2f0"
            ]
        ]
    },
    {
        "id": "a50e6fc76e6e8f77",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 540,
        "y": 1560,
        "wires": []
    },
    {
        "id": "d79424313dccb2f0",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1640,
        "wires": []
    },
    {
        "id": "0e18ed358d9967fb",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 5",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1220,
        "y": 1500,
        "wires": []
    },
    {
        "id": "9a5002eb64eee3d0",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/robots",
        "url": "/api/robots",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 360,
        "y": 1740,
        "wires": [
            [
                "1099aa542425c508"
            ]
        ]
    },
    {
        "id": "1099aa542425c508",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "buildRobotsResponse",
        "func": "// // global.robotsë¥¼ ì½ì–´ì„œ API ì‘ë‹µ í˜•íƒœë¡œ ë§Œë“¤ì–´ì£¼ëŠ” í•¨ìˆ˜\n\n// const robotsObj = global.get('robots') || {};\n// const robotsArr = [];\n\n// // ê°ì²´ â†’ ë°°ì—´ë¡œ ë³€í™˜\n// for (const id in robotsObj) {\n//     const r = robotsObj[id] || {};\n//     robotsArr.push(r);\n// }\n\n// // JSON ì‘ë‹µ í˜•íƒœ ì„¸íŒ…\n// msg.payload = {\n//     robots: robotsArr\n// };\n\n// // í—¤ë”ì— JSONì´ë¼ê³  ëª…ì‹œ\n// msg.headers = {\n//     'Content-Type': 'application/json'\n// };\n\n// return msg;\n\nconst db = global.get(\"db\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = { error: \"firestore not ready\" };\n  return msg;\n}\n\nconst limit = Math.min(parseInt((msg.req?.query?.limit ?? \"100\"), 10) || 100, 500);\n\nreturn new Promise(async (resolve) => {\n  try {\n    // updated_at ê¸°ì¤€ ìµœì‹ ìˆœ (í•„ë“œ ì—†ìœ¼ë©´ ì¸ë±ìŠ¤/ì •ë ¬ ì´ìŠˆ ê°€ëŠ¥)\n    let q = db.collection(\"robots\");\n\n    // orderByëŠ” í•„ë“œê°€ ì•ˆì •ì ìœ¼ë¡œ ë“¤ì–´ê°€ì•¼ í•¨. ì•ˆ ë“¤ì–´ê°„ ë¬¸ì„œê°€ ìˆìœ¼ë©´ ì •ë ¬ì—ì„œ ë¹ ì§ˆ ìˆ˜ ìˆìŒ.\n    // ë„ˆ updateStatusì—ì„œ updated_atì„ í•­ìƒ ë„£ê³  ìˆì–´ì„œ OK. :contentReference[oaicite:2]{index=2}\n    q = q.orderBy(\"updated_at\", \"desc\").limit(limit);\n\n    const snap = await q.get();\n    const robots = snap.docs.map(d => d.data());\n\n    msg.statusCode = 200;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { robots };\n    resolve(msg);\n  } catch (err) {\n    node.error(err);\n    msg.statusCode = 500;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { error: \"failed to fetch robots\", detail: String(err?.message || err) };\n    resolve(msg);\n  }\n});",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 1740,
        "wires": [
            [
                "04c572829db161a8"
            ]
        ]
    },
    {
        "id": "04c572829db161a8",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/robots",
        "statusCode": "",
        "headers": {},
        "x": 940,
        "y": 1740,
        "wires": []
    },
    {
        "id": "cf9e4d5c0ec26f3f",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/tasks",
        "url": "/api/tasks",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 360,
        "y": 1820,
        "wires": [
            [
                "4db69741e35d7aaa"
            ]
        ]
    },
    {
        "id": "4db69741e35d7aaa",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "buildTasksResponse",
        "func": "// let tasks = global.get('taskQueue') || [];\n\n// // ìµœì‹ ìˆœ ì •ë ¬ (Vueì—ì„œ ë³´ê¸° ì¢‹ê²Œ)\n// tasks = tasks.slice().sort((a, b) => (b.created_at || 0) - (a.created_at || 0));\n\n// msg.payload = { tasks };\n// msg.headers = { \"Content-Type\": \"application/json\" };\n// return msg;\n\nconst db = global.get(\"db\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = { error: \"firestore not ready\" };\n  return msg;\n}\n\nconst q = msg.req?.query || {};\nconst status = (q.status || \"\").toString().trim(); // pending|running|done|failed ë“±\nconst limit = Math.min(parseInt((q.limit ?? \"50\"), 10) || 50, 500);\n\nreturn new Promise(async (resolve) => {\n  try {\n    let ref = db.collection(\"tasks\");\n\n    // status í•„í„° (ì˜µì…˜)\n    if (status) {\n      ref = ref.where(\"status\", \"==\", status);\n      // where + orderBy ì¡°í•© ì‹œ ì¸ë±ìŠ¤ í•„ìš”í•  ìˆ˜ ìˆìŒ (ì—ëŸ¬ ë©”ì‹œì§€ì— ìƒì„± ë§í¬ ë‚˜ì˜´)\n    }\n\n    // created_at ìµœì‹ ìˆœ\n    ref = ref.orderBy(\"created_at\", \"desc\").limit(limit);\n\n    const snap = await ref.get();\n    const tasks = snap.docs.map(d => d.data());\n\n    msg.statusCode = 200;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { tasks };\n    resolve(msg);\n  } catch (err) {\n    node.error(err);\n    msg.statusCode = 500;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { error: \"failed to fetch tasks\", detail: String(err?.message || err) };\n    resolve(msg);\n  }\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 1820,
        "wires": [
            [
                "bd552ae11c61fc7b"
            ]
        ]
    },
    {
        "id": "bd552ae11c61fc7b",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/tasks",
        "statusCode": "",
        "headers": {},
        "x": 930,
        "y": 1820,
        "wires": []
    },
    {
        "id": "3dc12e5ce8d5567e",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/events",
        "url": "/api/events",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 360,
        "y": 1900,
        "wires": [
            [
                "47eeabd70b7c449b"
            ]
        ]
    },
    {
        "id": "47eeabd70b7c449b",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "buildEventsResponse",
        "func": "// let events = global.get('events') || [];\n\n// // ìµœì‹ ìˆœ ì •ë ¬\n// events = events.slice().sort((a, b) => (b.ts || 0) - (a.ts || 0));\n\n// msg.payload = { events };\n// msg.headers = { \"Content-Type\": \"application/json\" };\n// return msg;\n\nconst db = global.get(\"db\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = { error: \"firestore not ready\" };\n  return msg;\n}\n\nconst limit = Math.min(parseInt((msg.req?.query?.limit ?? \"50\"), 10) || 50, 500);\n\nreturn new Promise(async (resolve) => {\n  try {\n    const snap = await db\n      .collection(\"events\")\n      .orderBy(\"ts\", \"desc\")\n      .limit(limit)\n      .get();\n\n    const events = snap.docs.map(d => d.data());\n\n    msg.statusCode = 200;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { events };\n    resolve(msg);\n  } catch (err) {\n    node.error(err);\n    msg.statusCode = 500;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { error: \"failed to fetch events\", detail: String(err?.message || err) };\n    resolve(msg);\n  }\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 1900,
        "wires": [
            [
                "14173b48771091af"
            ]
        ]
    },
    {
        "id": "14173b48771091af",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/events",
        "statusCode": "",
        "headers": {},
        "x": 940,
        "y": 1900,
        "wires": []
    },
    {
        "id": "aae26e35525d4347",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/summary",
        "url": "/api/summary",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 370,
        "y": 1980,
        "wires": [
            [
                "3252b669c8d4ee2a"
            ]
        ]
    },
    {
        "id": "3252b669c8d4ee2a",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "buildSummaryResponse",
        "func": "// const robots = global.get('robots') || {};\n// const tasks = global.get('taskQueue') || [];\n\n// let total = 0, idle = 0, running = 0, charging = 0, error = 0, others = 0;\n// for (const id in robots) {\n//     total++;\n//     const s = (robots[id].state || '').toLowerCase();\n//     if (s === 'idle') idle++;\n//     else if (s === 'running') running++;\n//     else if (s === 'charging') charging++;\n//     else if (s === 'error' || s === 'failed' || s === 'fault') error++;\n//     else others++;\n// }\n\n// let tTotal = tasks.length;\n// let tPending = 0, tRunning = 0, tDone = 0, tFailed = 0;\n// for (const t of tasks) {\n//     const s = (t.status || '').toLowerCase();\n//     if (s === 'pending') tPending++;\n//     else if (s === 'running') tRunning++;\n//     else if (s === 'done') tDone++;\n//     else if (s === 'failed') tFailed++;\n// }\n\n// msg.payload = {\n//     robots: { total, idle, running, charging, error, others },\n//     tasks:  { total: tTotal, pending: tPending, running: tRunning, done: tDone, failed: tFailed }\n// };\n// msg.headers = { \"Content-Type\": \"application/json\" };\n// return msg;\n\nconst db = global.get(\"db\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = { error: \"firestore not ready\" };\n  return msg;\n}\n\nconst q = msg.req?.query || {};\nconst taskLimit = Math.min(parseInt((q.taskLimit ?? \"200\"), 10) || 200, 1000);\n\nfunction countBy(list, keyFn) {\n  const m = {};\n  for (const x of list) {\n    const k = (keyFn(x) || \"unknown\").toLowerCase();\n    m[k] = (m[k] || 0) + 1;\n  }\n  return m;\n}\n\nreturn new Promise(async (resolve) => {\n  try {\n    // 1) robots ì „ë¶€ ì½ì–´ì„œ ìƒíƒœ ì¹´ìš´íŠ¸\n    const robotsSnap = await db.collection(\"robots\").get();\n    const robots = robotsSnap.docs.map(d => d.data());\n    const robotCounts = countBy(robots, r => r.state);\n\n    const robotSummary = {\n      total: robots.length,\n      idle: robotCounts.idle || 0,\n      running: robotCounts.running || 0,\n      charging: robotCounts.charging || 0,\n      error: (robotCounts.error || 0) + (robotCounts.failed || 0) + (robotCounts.fault || 0),\n      others:\n        (robotCounts.offline || 0) +\n        (robotCounts.unknown || 0)\n    };\n\n    // 2) tasksëŠ” ìµœê·¼ Nê°œë§Œ ì½ì–´ì„œ ìƒíƒœ ì¹´ìš´íŠ¸ (Phase 0 ê°€ë²¼ìš´ ì§‘ê³„)\n    const tasksSnap = await db\n      .collection(\"tasks\")\n      .orderBy(\"created_at\", \"desc\")\n      .limit(taskLimit)\n      .get();\n\n    const tasks = tasksSnap.docs.map(d => d.data());\n    const taskCounts = countBy(tasks, t => t.status);\n\n    const taskSummary = {\n      total: tasks.length,\n      pending: taskCounts.pending || 0,\n      running: taskCounts.running || 0,\n      done: taskCounts.done || 0,\n      failed: taskCounts.failed || 0\n    };\n\n    msg.statusCode = 200;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { robots: robotSummary, tasks: taskSummary, meta: { taskLimit } };\n    resolve(msg);\n  } catch (err) {\n    node.error(err);\n    msg.statusCode = 500;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { error: \"failed to fetch summary\", detail: String(err?.message || err) };\n    resolve(msg);\n  }\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 1980,
        "wires": [
            [
                "bb5bd9f96e8e8313"
            ]
        ]
    },
    {
        "id": "bb5bd9f96e8e8313",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/summary",
        "statusCode": "",
        "headers": {},
        "x": 950,
        "y": 1980,
        "wires": []
    },
    {
        "id": "a90b7ad07ef61884",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "FIrestore Client Init",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 370,
        "y": 80,
        "wires": [
            [
                "f1509788aad45a75"
            ]
        ]
    },
    {
        "id": "f1509788aad45a75",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "Init Firestore",
        "func": "// admin, fs ëŠ” Function ë…¸ë“œ Setup(Modules)ì—ì„œ ì£¼ì…ë°›ëŠ”ë‹¤ê³  ê°€ì •\n\n// const keyPath = \"C:/Users/wp3wk/AppData/Roaming/SPB_Data/.node-red/agv-pjt2-firebase-adminsdk-fbsvc-18055a3bd9.json\"; // ë‚´ íŒŒì´ì–´ìŠ¤í† ì–´\nconst keyPath = \"C:/Users/wp3wk/AppData/Roaming/SPB_Data/.node-red/agv-pjt2-9d394-firebase-adminsdk-fbsvc-9079c95fe9.json\" // ìœ ì§„ì´ íŒŒì´ì–´ìŠ¤í† ì–´\n// 0) ì„œë¹„ìŠ¤ ê³„ì • íŒŒì¼ ì¡´ì¬ í™•ì¸\nif (!fs.existsSync(keyPath)) {\n  node.error(\"âŒ Service account json not found: \" + keyPath);\n  return null;\n}\n\nconst serviceAccount = JSON.parse(fs.readFileSync(keyPath, \"utf8\"));\n\n// 1) ê¸°ì¡´ firebase-admin ì•±ì´ ìˆìœ¼ë©´ ì œê±° (í”„ë¡œì íŠ¸ ë³€ê²½ ì‹œ í•„ìˆ˜)\nif (admin.apps && admin.apps.length > 0) {\n  return admin.app().delete().then(() => {\n    node.warn(\"â™»ï¸ Old firebase app deleted. Re-initializing...\");\n    return init();\n  }).catch(err => {\n    node.error(\"âŒ Failed to delete old firebase app: \" + err.message);\n    return null;\n  });\n}\n\n// 2) ì‹¤ì œ ì´ˆê¸°í™” í•¨ìˆ˜\nfunction init() {\n  admin.initializeApp({\n    credential: admin.credential.cert(serviceAccount),\n  });\n\n  const db = admin.firestore();\n\n  global.set(\"admin\", admin);\n  global.set(\"db\", db);\n  global.set(\"firestoreReady\", true);\n\n  // 3) healthcheck write (ì„±ê³µ ì—¬ë¶€ ëª…í™•íˆ í™•ì¸)\n  return db.collection(\"_healthcheck\").doc(\"init\").set({\n    ts: Date.now(),\n    project_id: serviceAccount.project_id,\n  }).then(() => {\n    node.warn(\"âœ… Firestore initialized!\");\n    node.warn(\"ğŸ‘‰ project_id = \" + serviceAccount.project_id);\n    return null;\n  }).catch(err => {\n    node.error(\"âŒ Firestore healthcheck write failed: \" + err.message);\n    return null;\n  });\n}\n\nreturn init();\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "admin",
                "module": "firebase-admin"
            },
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 610,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "2ccacb1608c5ba74",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "FS : write task (create)",
        "func": "const db = global.get(\"db\");\nif (!db) {\n    node.warn(\"Firestore not ready - skip write\");\n    return msg;\n}\n\nconst task = msg.task;\nif (!task || !task.task_id) return msg;\n\ndb.collection(\"tasks\").doc(task.task_id).set(task, { merge: true })\n    .then(() => node.warn(`FS task created: ${task.task_id}`))\n    .catch(err => node.error(err));\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1120,
        "wires": [
            [
                "8fa070ba704430fc",
                "ce111f86ccf22e93"
            ]
        ]
    },
    {
        "id": "58d8d616da6872e1",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "FS: update task (assigned)",
        "func": "const db = global.get(\"db\");\nif (!db) return msg;\n\nconst task = msg.task;\nif (!task || !task.task_id) return msg;\n\ndb.collection(\"tasks\").doc(task.task_id).set(task, { merge: true })\n    .then(() => node.warn(`FS task assigned: ${task.task_id}`))\n    .catch(err => node.error(err));\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1780,
        "y": 1120,
        "wires": [
            [
                "c02ac5399c925f84"
            ]
        ]
    },
    {
        "id": "241f54b35e15895f",
        "type": "delay",
        "z": "49f8711fc297a8c1",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "2",
        "nbRateUnits": "",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": true,
        "outputs": 1,
        "x": 1040,
        "y": 1480,
        "wires": [
            [
                "e5f2fa78b4c8f5b4",
                "0e18ed358d9967fb"
            ]
        ]
    },
    {
        "id": "54431a46252d1602",
        "type": "http request",
        "z": "49f8711fc297a8c1",
        "name": "",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://gms.ssafy.io/gmsapi/api.openai.com/v1/chat/completions",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 910,
        "y": 480,
        "wires": [
            [
                "7dea3543f230c5e1",
                "fd22aea86440924f"
            ]
        ]
    },
    {
        "id": "c301115701d2a789",
        "type": "mqtt out",
        "z": "49f8711fc297a8c1",
        "name": "",
        "topic": "",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "3c16a07776b27396",
        "x": 1930,
        "y": 520,
        "wires": []
    },
    {
        "id": "1f3be0f0cf23a955",
        "type": "telegram sender",
        "z": "49f8711fc297a8c1",
        "name": "",
        "bot": "d10c4415b361b866",
        "haserroroutput": false,
        "outputs": 1,
        "x": 1950,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "7dea3543f230c5e1",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "LLMValidate",
        "func": "// const chatId = msg._tg?.chatId;\n// const raw = msg._tg?.raw || \"\";\n// const interactionId = msg._interactionId;\n\n// if (!interactionId) {\n//   node.error(\"LLMValidate: missing msg._interactionId\", msg);\n//   return null;\n// }\n\n\n// function makeReply(content) {\n//   return { payload: { chatId, type: \"message\", content } };\n// }\n\n// function fsUpdate(patch) {\n//   return {\n//     payload: {\n//       interaction_id: interactionId,\n//       updated_at: Date.now(),\n//       ...patch\n//     }\n//   };\n// }\n\n// // content êº¼ë‚´ê¸°\n// let content = msg.payload?.choices?.[0]?.message?.content || \"\";\n\n// // JSONë§Œ ì¶”ì¶œ\n// function extractJson(text) {\n//   if (!text) return null;\n//   text = text.replace(/```json\\s*/g, \"\").replace(/```\\s*/g, \"\").trim();\n//   const s = text.indexOf(\"{\");\n//   const e = text.lastIndexOf(\"}\");\n//   if (s === -1 || e === -1 || e <= s) return null;\n//   return text.slice(s, e + 1);\n// }\n\n// const jsonStr = extractJson(content);\n// if (!jsonStr) {\n//   const fsMsg = fsUpdate({\n//     result: \"rejected\",\n//     error: { stage: \"llm/validate\", message: \"no json extracted\" }\n//   });\n//   return [makeReply(\"ì£„ì†¡í•´ìš” ğŸ˜¥ ìš”ì²­ì„ ì´í•´í•˜ì§€ ëª»í–ˆì–´ìš”. ë²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ í•´ì£¼ì„¸ìš”.\"), null, fsMsg];\n// }\n\n// let parsed;\n// try { parsed = JSON.parse(jsonStr); }\n// catch {\n//   const fsMsg = fsUpdate({\n//     result: \"rejected\",\n//     error: { stage: \"llm/validate\", message: \"json parse failed\" }\n//   });\n//   return [makeReply(\"ì£„ì†¡í•´ìš” ğŸ˜¥ ìš”ì²­ í•´ì„ ê²°ê³¼ê°€ ê¹¨ì¡Œì–´ìš”. ë²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ í•´ì£¼ì„¸ìš”.\"), null, fsMsg];\n// }\n\n// // allow-list\n// const ALLOW_TYPE = new Set([\"deliver_water\", \"collect_cup\", \"collect_laundry\"]);\n// const ALLOW_AREA = new Set([\"USER1\", \"USER2\", \"DOCK\", \"BASE\"]);\n\n// const type = parsed.type;\n// let area = parsed.target_area;\n\n// // typeì€ ë°˜ë“œì‹œ ìˆì–´ì•¼ í•¨\n// if (!ALLOW_TYPE.has(type)) {\n//   const fsMsg = fsUpdate({\n//     result: \"rejected\",\n//     error: { stage: \"llm/validate\", message: `type not allowed: ${String(type)}` },\n//     parsed: { type: String(type || \"\"), target_area: String(parsed?.target_area || \"\"), confidence: parsed?.confidence ?? null }\n//   });\n//   return [makeReply(\"ë¬´ìŠ¨ ìš”ì²­ì¸ì§€ íŒë‹¨í•˜ì§€ ëª»í–ˆì–´ìš” ğŸ˜¥\\në²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.\"), null, fsMsg];\n// }\n\n// // âœ… default area fallback (ì„ì‹œ: flowì— ì €ì¥, ì—†ìœ¼ë©´ USER1)\n// let defaultArea = flow.get(\"default_area_\" + chatId);\n// if (!defaultArea) defaultArea = \"USER1\";\n\n// // âœ… areaê°€ ì—†ê±°ë‚˜ ì´ìƒí•˜ë©´ defaultë¡œ ì±„ì›€\n// if (!ALLOW_AREA.has(area)) {\n//   area = defaultArea;\n// }\n\n// // topic ê²°ì •\n// const topic =\n//   type === \"deliver_water\" ? \"cmd/water/request\" :\n//   type === \"collect_cup\" ? \"cmd/cup/request\" :\n//   \"cmd/laundry/request\";\n\n// // mqtt\n// const mqttMsg = {\n//   topic,\n//   payload: JSON.stringify({\n//     type,\n//     target_area: area,\n//     user_id: `tg_${chatId}`,\n//     meta: {\n//       source: \"telegram\",\n//       input: \"text\",\n//       raw,\n//       default_area_used: !parsed.target_area,\n//       interaction_id: interactionId\n//     }\n//   })\n// };\n\n// const pretty =\n//   type === \"deliver_water\" ? \"ë¬¼ ë°°ë‹¬\" :\n//   type === \"collect_cup\" ? \"ì»µ ìˆ˜ê±°\" : \"ì„¸íƒë¬¼ ìˆ˜ê±°\";\n\n// const usedMsg = (!parsed.target_area) ? ` (ê¸°ë³¸ ìœ„ì¹˜: ${area})` : \"\";\n\n// const fsMsg = fsUpdate({\n//   result: \"accepted\",\n//   parsed: { type, target_area: area, confidence: parsed?.confidence ?? null }\n// });\n\n// return [makeReply(`âœ… ${pretty} ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš”!${usedMsg}`), mqttMsg, fsMsg];\n\nconst chatId = msg._tg?.chatId;\nconst raw = msg._tg?.raw || \"\";\nconst interactionId = msg._interactionId;\n\nif (!interactionId) {\n  node.error(\"LLMValidate: missing msg._interactionId\", msg);\n  return null;\n}\n\nfunction makeReply(content) {\n  return { payload: { chatId, type: \"message\", content } };\n}\n\nfunction fsUpdate(patch) {\n  return {\n    payload: {\n      interaction_id: interactionId,\n      updated_at: Date.now(),\n      ...patch\n    }\n  };\n}\n\n// content êº¼ë‚´ê¸°\nlet content = msg.payload?.choices?.[0]?.message?.content || \"\";\n\n// JSONë§Œ ì¶”ì¶œ\nfunction extractJson(text) {\n  if (!text) return null;\n  text = text.replace(/```json\\s*/g, \"\").replace(/```\\s*/g, \"\").trim();\n  const s = text.indexOf(\"{\");\n  const e = text.lastIndexOf(\"}\");\n  if (s === -1 || e === -1 || e <= s) return null;\n  return text.slice(s, e + 1);\n}\n\nconst jsonStr = extractJson(content);\nif (!jsonStr) {\n  const fsMsg = fsUpdate({\n    result: \"rejected\",\n    error: { stage: \"llm/validate\", message: \"no json extracted\" }\n  });\n  return [makeReply(\"ì£„ì†¡í•´ìš” ğŸ˜¥ ìš”ì²­ì„ ì´í•´í•˜ì§€ ëª»í–ˆì–´ìš”.\\në²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ í•´ì£¼ì„¸ìš”.\"), null, fsMsg];\n}\n\nlet parsed;\ntry { parsed = JSON.parse(jsonStr); }\ncatch {\n  const fsMsg = fsUpdate({\n    result: \"rejected\",\n    error: { stage: \"llm/validate\", message: \"json parse failed\" }\n  });\n  return [makeReply(\"ì£„ì†¡í•´ìš” ğŸ˜¥ ìš”ì²­ í•´ì„ ê²°ê³¼ê°€ ê¹¨ì¡Œì–´ìš”.\\në²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ í•´ì£¼ì„¸ìš”.\"), null, fsMsg];\n}\n\n// allow-list\nconst ALLOW_TYPE = new Set([\"deliver_water\", \"collect_cup\", \"collect_laundry\"]);\nconst ALLOW_AREA = new Set([\"USER1\", \"USER2\", \"DOCK\", \"BASE\"]);\n\nconst type = parsed.type;\nlet area = parsed.target_area;\n\n// typeì€ ë°˜ë“œì‹œ ìˆì–´ì•¼ í•¨\nif (!ALLOW_TYPE.has(type)) {\n  const fsMsg = fsUpdate({\n    result: \"rejected\",\n    error: { stage: \"llm/validate\", message: `type not allowed: ${String(type)}` },\n    parsed: { type: String(type || \"\"), target_area: String(parsed?.target_area || \"\"), confidence: parsed?.confidence ?? null }\n  });\n  return [makeReply(\"ë¬´ìŠ¨ ìš”ì²­ì¸ì§€ íŒë‹¨í•˜ì§€ ëª»í–ˆì–´ìš” ğŸ˜¥\\në²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.\"), null, fsMsg];\n}\n\n// âœ… default area fallback (ì„ì‹œ: flowì— ì €ì¥, ì—†ìœ¼ë©´ USER1)\nlet defaultArea = flow.get(\"default_area_\" + chatId);\nif (!defaultArea) defaultArea = \"USER1\";\n\n// âœ… areaê°€ ì—†ê±°ë‚˜ ì´ìƒí•˜ë©´ defaultë¡œ ì±„ì›€\nif (!ALLOW_AREA.has(area)) {\n  area = defaultArea;\n}\n\n// topic ê²°ì •\nconst topic =\n  type === \"deliver_water\" ? \"cmd/water/request\" :\n  type === \"collect_cup\" ? \"cmd/cup/request\" :\n  \"cmd/laundry/request\";\n\n// mqtt\nconst mqttMsg = {\n  topic,\n  payload: JSON.stringify({\n    type,\n    target_area: area,\n    user_id: `tg_${chatId}`,\n    meta: {\n      source: \"telegram\",\n      input: \"text\", // or 'voice' if passed\n      raw,\n      default_area_used: !parsed.target_area,\n      interaction_id: interactionId\n    }\n  })\n};\n\n// -----------------------------------------------------------\n// âœ… ì‘ë‹µ ë©”ì‹œì§€ í†µì¼ (Button ë…¸ë“œì™€ ë™ì¼í•œ ë©˜íŠ¸ ì ìš©)\n// -----------------------------------------------------------\nlet replyContent = \"\";\n\nif (type === \"deliver_water\") {\n  replyContent = \"ë¬¼ ë°°ë‹¬ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš” ğŸ’§\\nê¸ˆë°© ê°–ë‹¤ë“œë¦´ê²Œìš”!\";\n} \nelse if (type === \"collect_cup\") {\n  replyContent = \"ì»µ íšŒìˆ˜ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš” ğŸ¥¤\\në°”ë¡œ ì²˜ë¦¬í• ê²Œìš”!\";\n} \nelse if (type === \"collect_laundry\") {\n  // LLMì´ 'í™˜ê²½ì •ë¦¬/ì„¸íƒë¬¼' ë“±ìœ¼ë¡œ ì¸ì‹í•´ì„œ collect_laundryë¥¼ ë±‰ìœ¼ë©´ ì´ ë©˜íŠ¸\n  replyContent = \"í™˜ê²½ ì •ë¦¬ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆì–´ìš” ğŸ§¹\\nì£¼ë³€ì„ ê¹”ë”í•˜ê²Œ ì •ë¦¬í• ê²Œìš”!\";\n}\n\nconst fsMsg = fsUpdate({\n  result: \"accepted\",\n  parsed: { type, target_area: area, confidence: parsed?.confidence ?? null }\n});\n\nreturn [makeReply(replyContent), mqttMsg, fsMsg];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 480,
        "wires": [
            [
                "1f3be0f0cf23a955"
            ],
            [
                "c301115701d2a789"
            ],
            [
                "350dfce793e04058"
            ]
        ]
    },
    {
        "id": "fd22aea86440924f",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 6",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 500,
        "wires": []
    },
    {
        "id": "350dfce793e04058",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "write interaction(upsert)",
        "func": "const db = global.get(\"db\");\nif (!db) {\n  node.warn(\"Firestore not ready - skip interaction write\");\n  return msg;\n}\n\nconst interaction = msg.payload; // âœ… ì—¬ê¸°!\nif (!interaction || !interaction.interaction_id) return msg;\n\ndb.collection(\"interactions\")\n  .doc(interaction.interaction_id)\n  .set(interaction, { merge: true })\n  .then(() => node.warn(`FS interaction upsert: ${interaction.interaction_id}`))\n  .catch(err => node.error(err));\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1810,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "1c0f552d8a376fcc",
        "type": "http request",
        "z": "49f8711fc297a8c1",
        "name": "",
        "method": "use",
        "ret": "bin",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1030,
        "y": 860,
        "wires": [
            [
                "04db854fab84c358"
            ]
        ]
    },
    {
        "id": "04db854fab84c358",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "Voice: build whisper request",
        "func": "const fs = global.get(\"fs\");\nconst path = global.get(\"path\");\nconst tempDir = global.get(\"tempDir\");\n\nif (!fs.existsSync(tempDir)) {\n  fs.mkdirSync(tempDir, { recursive: true });\n}\n\nconst filePath = path.join(\n  tempDir,\n  `tg_voice_${Date.now()}.oga`\n);\n\nfs.writeFileSync(filePath, msg.payload);\n\nmsg.voicePath = filePath;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 860,
        "wires": [
            [
                "37ab14c5f1fb76e5"
            ]
        ]
    },
    {
        "id": "8f2038d41f373286",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "Voice: build LLMReq for chat/completions",
        "func": "const chatId = msg._tg?.chatId;\nconst interactionId = msg._interactionId;\nconst text = (msg.payload?.text || \"\").trim();\n\nif (!text) {\n  // ì‹¤íŒ¨: í…”ë ˆê·¸ë¨ ì‘ë‹µ + FS updateë¡œ ë³´ë‚´ê³  ëë‚´ë„ ë¨\n  msg.payload = { chatId, type:\"message\", content:\"ğŸ™ï¸ ìŒì„±ì„ ì¸ì‹í•˜ì§€ ëª»í–ˆì–´ìš”. ë‹¤ì‹œ ë§í•´ ì£¼ì„¸ìš”.\", options:{} };\n  return [msg, null];\n}\n\n// âœ… ì—¬ê¸°ì„œë¶€í„°ëŠ” Function1ì´ ë§Œë“¤ë˜ llmReqì™€ ì™„ì „íˆ ë™ì¼í•œ í˜•íƒœë¡œ ë§Œë“¤ê¸°\nmsg.headers = {\n  \"Content-Type\": \"application/json\",\n  \"Authorization\": `Bearer ${global.get(\"GMS_KEY\")}`\n};\n\nmsg.payload = {\n  model: \"gpt-4.1-nano\",\n  temperature: 0.2,\n  max_tokens: 200,\n  messages: [\n    {\n      role: \"system\",\n      content:\n        \"ë„ˆëŠ” AGV ì‚¬ìš©ì ì•±ì˜ ëª…ë ¹ íŒŒì„œë‹¤. ë°˜ë“œì‹œ JSONë§Œ ì¶œë ¥í•´.\\n\" +\n        \"í—ˆìš© type: deliver_water, collect_cup, collect_laundry\\n\" +\n        \"í—ˆìš© target_area: USER1, USER2, DOCK, BASE\\n\" +\n        'í˜•ì‹: {\"type\":\"...\",\"target_area\":\"...\",\"confidence\":0.0}\\n' +\n        \"ì¶”ë¡  ì„¤ëª… ê¸ˆì§€. JSON ì™¸ í…ìŠ¤íŠ¸ ê¸ˆì§€.\"\n    },\n    { role: \"user\", content: text }\n  ]\n};\n\n// validateì—ì„œ ì“°ëŠ” ë©”íƒ€ ìœ ì§€\nmsg._tg = { chatId, raw: text };\nmsg._interactionId = interactionId;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2520,
        "y": 860,
        "wires": [
            [
                "54431a46252d1602"
            ]
        ]
    },
    {
        "id": "f65016bb2f2505ba",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "Set Url",
        "func": "// Voice: set url\nmsg.method = \"GET\";\nmsg.url = msg.weblink;              // âœ… ì‹¤ì œ ê°’(https://api.telegram.org/...)ì´ ë“¤ì–´ê°\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 860,
        "wires": [
            [
                "1c0f552d8a376fcc"
            ]
        ]
    },
    {
        "id": "37ab14c5f1fb76e5",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "build exec cmd",
        "func": "const fs = global.get(\"fs\");\nconst key = global.get(\"GMS_KEY\");\n\nif (!msg.voicePath) { node.error(\"voicePath missing\", msg); return null; }\nif (!fs.existsSync(msg.voicePath)) { node.error(\"voice file not found: \" + msg.voicePath, msg); return null; }\n\nconst boundary = \"----NodeRedFormBoundary\" + Date.now();\nconst CRLF = \"\\r\\n\";\n\n// íŒŒì¼ ì½ê¸° (Buffer)\nconst fileBuf = fs.readFileSync(msg.voicePath);\n\n// multipart íŒŒíŠ¸ë“¤ ë§Œë“¤ê¸°\nfunction partText(name, value) {\n  return Buffer.from(\n    `--${boundary}${CRLF}` +\n    `Content-Disposition: form-data; name=\"${name}\"${CRLF}${CRLF}` +\n    `${value}${CRLF}`\n  );\n}\n\nfunction partFile(name, filename, contentType, dataBuf) {\n  const head = Buffer.from(\n    `--${boundary}${CRLF}` +\n    `Content-Disposition: form-data; name=\"${name}\"; filename=\"${filename}\"${CRLF}` +\n    `Content-Type: ${contentType}${CRLF}${CRLF}`\n  );\n  const tail = Buffer.from(CRLF);\n  return Buffer.concat([head, dataBuf, tail]);\n}\n\nconst end = Buffer.from(`--${boundary}--${CRLF}`);\n\nconst body = Buffer.concat([\n  partText(\"model\", \"whisper-1\"),\n  partFile(\"file\", \"voice.oga\", \"audio/ogg\", fileBuf),\n  end\n]);\n\nmsg.method = \"POST\";\nmsg.url = \"https://gms.ssafy.io/gmsapi/api.openai.com/v1/audio/transcriptions\";\nmsg.headers = {\n  \"Authorization\": `Bearer ${key}`,\n  \"Content-Type\": `multipart/form-data; boundary=${boundary}`,\n  \"Content-Length\": body.length\n};\nmsg.payload = body;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1620,
        "y": 860,
        "wires": [
            [
                "44fe72582d9db9b2"
            ]
        ]
    },
    {
        "id": "996820a5df9eae6f",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "parse whisper result",
        "func": "let obj = null;\ntry {\n  obj = JSON.parse(msg.payload);\n} catch (e) {\n  node.error(\"Whisper response not JSON\", msg);\n  return null;\n}\n\nconst text = (obj.text || \"\").trim();\nif (!text) {\n  msg.payload = { text: \"\" };\n  return msg;\n}\n\n// ------------------------------\n// âœ… ì—¬ê¸°ë¶€í„° ì¶”ê°€: Firestore interaction ì •ë¦¬(clean-up)\n// - raw_input = STT í…ìŠ¤íŠ¸ë¡œ ë®ì–´ì“°ê¸°\n// - meta(weblink ë“±) ì‚­ì œ\n// ------------------------------\nconst db = global.get(\"db\");\nconst admin = global.get(\"admin\");        // globalì— admin ì˜¬ë ¤ë‘” ê²½ìš°\nconst interactionId = msg._interactionId; // voice íŒŒì´í”„ì—ì„œ ìœ ì§€ ì¤‘ì¸ ê°’\n\nif (db && admin && interactionId) {\n  const FieldValue = admin.firestore.FieldValue;\n\n  db.collection(\"interactions\").doc(interactionId).set({\n    raw_input: text,                 // âœ… ì •ì œëœ í…ìŠ¤íŠ¸ë¡œ êµì²´\n    meta: FieldValue.delete(),       // âœ… meta í†µì§¸ë¡œ ì œê±°\n    updated_at: Date.now()\n  }, { merge: true })\n    .then(() => node.warn(`FS voice cleaned: ${interactionId}`))\n    .catch(err => node.error(err));\n} else {\n  node.warn(\"FS cleanup skipped (missing db/admin/interactionId)\");\n}\n\n// ë‹¤ìŒ ë…¸ë“œë¡œ text ë„˜ê¸°ê¸°\nmsg.payload = { text };\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2140,
        "y": 860,
        "wires": [
            [
                "8f2038d41f373286"
            ]
        ]
    },
    {
        "id": "44fe72582d9db9b2",
        "type": "http request",
        "z": "49f8711fc297a8c1",
        "name": "",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1870,
        "y": 860,
        "wires": [
            [
                "996820a5df9eae6f"
            ]
        ]
    },
    {
        "id": "f0fa65d36b46ef73",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/user/summary",
        "url": "/api/user/summary",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 380,
        "y": 2040,
        "wires": [
            [
                "66ef6c3af246f209"
            ]
        ]
    },
    {
        "id": "66ef6c3af246f209",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "buildUserSummaryResponse",
        "func": "// GET /api/user/summary?user_id=tg_...\n\nconst q = msg.req?.query || {};\nconst userId = q.user_id || q.uid || null;\n\nif (!userId) {\n    msg.statusCode = 400;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { error: \"missing user_id\" };\n    return msg;\n}\n\nconst robots = global.get(\"robots\") || {};\nconst taskQueue = global.get(\"taskQueue\") || [];\nconst taskStats = global.get(\"taskStats\") || {};\n\nconst r = robots[\"agv1\"] || null;\n\n// ---- labels\nconst AREA_LABEL = { BASE: \"ë² ì´ìŠ¤\", DOCK: \"ë„í‚¹\", USER1: \"ì‚¬ìš©ì êµ¬ì—­ 1\", USER2: \"ì‚¬ìš©ì êµ¬ì—­ 2\", RES_A: \"ì‚¬ìš©ì êµ¬ì—­ 1\", RES_B: \"ì‚¬ìš©ì êµ¬ì—­ 2\", RES_C: \"ì‚¬ìš©ì êµ¬ì—­ 3\" };\nconst TYPE_LABEL = { deliver_water: \"â˜• ë¬¼ ë°°ë‹¬\", collect_cup: \"ğŸ¥¤ ì»µ íšŒìˆ˜\", collect_laundry: \"ğŸ§¹ í™˜ê²½ ì •ë¦¬\" };\n\nfunction areaName(a) { return AREA_LABEL[a] || a || \"â€”\"; }\nfunction typeName(t) { return TYPE_LABEL[t] || t || \"â€”\"; }\n\n// ---- expected duration\nconst DEFAULT_EXPECT_MS = { deliver_water: 20000, collect_cup: 15000, collect_laundry: 30000 };\n\nfunction expectedMsFor(type) {\n    const ema = taskStats?.[type]?.ema_ms;\n    if (ema != null) return Math.max(1000, Math.round(ema));\n    return DEFAULT_EXPECT_MS[type] || 20000;\n}\n\nconst now = Date.now();\n\n// ---- \"ë‚´ ì‘ì—…\"ë§Œ í•„í„°\nconst myTasks = taskQueue.filter(t => (t.user_id === userId));\n\n// ==========================================================\n// ğŸ”¥ [ê°•ì œ ì°¨ë‹¨ ë¡œì§ + ìœ ë ¹ ì‘ì—… ì†Œê°] ğŸ”¥\n// ==========================================================\nlet active = null;\n\n// ë¡œë´‡ì˜ ì‹¤ì œ ìƒíƒœ (ì†Œë¬¸ì ë³€í™˜)\nconst robotState = String(r?.state || \"idle\").toLowerCase();\n\n// 1. ë¡œë´‡ì´ ì‹¤ì œë¡œ 'ë°”ì¨' ìƒíƒœì¼ ë•Œë§Œ ë’¤ì ¸ë´„ (idle, charging, errorì¼ ë• ë¬´ì¡°ê±´ null)\nif (robotState === \"running\" || robotState === \"working\") {\n\n    // (A) ë¡œë´‡ì— í• ë‹¹ëœ Task IDê°€ ìˆìœ¼ë©´ ê·¸ê²Œ 1ìˆœìœ„\n    if (r?.task_id) {\n        active = myTasks.find(t => t.task_id === r.task_id) || null;\n    }\n\n    // (B) ID ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ, ìƒíƒœê°€ runningì¸ ë‚´ ì‘ì—… (ë‹¨, agv1 í• ë‹¹)\n    if (!active) {\n        active = myTasks.find(t => t.status === \"running\" && t.assigned_robot === \"agv1\") || null;\n    }\n}\n\n// ----------------------------------------------------------\n// â˜… [í•µì‹¬ ì¶”ê°€] ìœ ë ¹ ì‘ì—… í•„í„°ë§ (Ghost Task Filter) â˜…\n// ----------------------------------------------------------\n// active ì‘ì—…ì´ ì¡í˜”ë”ë¼ë„, 'ì‹œì‘ ì‹œê°„'ì´ ì—†ìœ¼ë©´ ê·¸ê±´ ìœ ë ¹ì…ë‹ˆë‹¤.\nif (active) {\n    const start = Number(active.started_at || 0);\n\n    // ì‹œì‘ ì‹œê°„ì´ 0ì´ê±°ë‚˜(ì´ˆê¸°ê°’), ë¯¸ë˜ ì‹œê°„ì´ê±°ë‚˜, ë„ˆë¬´ ì˜¤ë˜ëœ(24ì‹œê°„+) ì‘ì—…ì´ë©´\n    // -> ì´ê±´ \"ëŒ€ê¸° ì¤‘\"ì´ê±°ë‚˜ \"ì—ëŸ¬ë‚œ\" ì‘ì—…ì´ë¯€ë¡œ ì§„í–‰ ì¤‘(active)ì—ì„œ ëºë‹ˆë‹¤.\n    if (start <= 0 || (now - start > 86400000)) {\n        active = null;\n    }\n}\n// ==========================================================\n\n\n// ---- ETA ê³„ì‚°\nfunction etaRemainSec(task) {\n    if (!task) return null;\n    const expectedMs = Number(task.expected_duration_ms || 0) || expectedMsFor(task.type);\n    const startedAt = Number(task.started_at || 0);\n\n    // runningì´ê³  ì‹œì‘ ì‹œê°„ì´ ìˆì–´ì•¼ë§Œ ë‚¨ì€ ì‹œê°„ ê³„ì‚°\n    if ((task.status === \"running\") && (startedAt > 0)) {\n        const elapsed = now - startedAt;\n        return Math.max(0, Math.ceil((expectedMs - elapsed) / 1000));\n    }\n    return null;\n}\n\n// ---- ìƒíƒœ ë¼ë²¨\nfunction robotStateLabel(robot) {\n    if (!robot) return \"ìƒíƒœ ì—†ìŒ\";\n    const s = String(robot.state || \"unknown\").toLowerCase();\n    if (robot.error_code) return \"ì˜¤ë¥˜ â—\";\n    if (s === \"running\") return \"ì´ë™ ì¤‘ ğŸšš\";\n    if (s === \"charging\") return \"ì¶©ì „ ì¤‘ ğŸ”Œ\";\n    if (s === \"working\") return \"ì‘ì—… ì¤‘ âš™ï¸\";\n    if (s === \"idle\") return \"ëŒ€ê¸° ì¤‘ âœ…\";\n    return s;\n}\n\nconst nowObj = {\n    state_label: robotStateLabel(r),\n    battery: r?.battery ?? null,\n    area_label: r?.area ? areaName(r.area) : null,\n    error_label: r?.error_code ?? null,\n\n    // activeê°€ nullì´ë©´ UIëŠ” 'v-else'ë¥¼ íƒ€ì„œ \"í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤\"ë¥¼ í‘œì‹œí•¨\n    active: active ? {\n        type: active.type || null,\n        type_label: typeName(active.type),\n        target_area: active.target_area || null,\n        target_label: areaName(active.target_area),\n        status: active.status || null,\n        eta_remain_sec: etaRemainSec(active)\n    } : null\n};\n\n// ---- í†µê³„ ë° ìµœê·¼ ê¸°ë¡ (ê¸°ì¡´ ìœ ì§€)\nfunction startOfKstDay(ts = Date.now()) {\n    const k = new Date(ts + 9 * 3600 * 1000);\n    k.setUTCHours(0, 0, 0, 0);\n    return k.getTime() - 9 * 3600 * 1000;\n}\nfunction startOfKstWeek(ts = Date.now()) {\n    const k = new Date(ts + 9 * 3600 * 1000);\n    const day = k.getUTCDay();\n    const diff = (day === 0 ? 6 : day - 1);\n    k.setUTCDate(k.getUTCDate() - diff);\n    k.setUTCHours(0, 0, 0, 0);\n    return k.getTime() - 9 * 3600 * 1000;\n}\nconst dayStart = startOfKstDay(now);\nconst weekStart = startOfKstWeek(now);\n\nfunction countRange(startMs) {\n    const c = { deliver_water: 0, collect_cup: 0, collect_laundry: 0 };\n    for (const t of myTasks) {\n        const ts = Number(t.created_at || 0);\n        if (!ts || ts < startMs) continue;\n        if (t.type && (t.type in c)) c[t.type]++;\n    }\n    return c;\n}\n\nconst todayCnt = countRange(dayStart);\nconst weekCnt = countRange(weekStart);\nconst todayWater = todayCnt.deliver_water * 500;\nconst weekWater = weekCnt.deliver_water * 500;\n\nfunction topType(cnt) {\n    let best = null, bestV = -1;\n    for (const k of Object.keys(cnt)) {\n        if (cnt[k] > bestV) { bestV = cnt[k]; best = k; }\n    }\n    return bestV > 0 ? best : null;\n}\n\nconst recent = [...myTasks]\n    .sort((a, b) => Number(b.created_at || 0) - Number(a.created_at || 0))\n    .slice(0, 5)\n    .map(t => ({\n        ts: Number(t.created_at || 0),\n        type: t.type || null,\n        type_label: typeName(t.type),\n        target_area: t.target_area || null,\n        target_label: areaName(t.target_area),\n        status: t.status || \"unknown\"\n    }));\n\nmsg.statusCode = 200;\nmsg.headers = { \"Content-Type\": \"application/json\" };\nmsg.payload = {\n    user_id: userId,\n    now: nowObj,\n    today: { ...todayCnt, water_ml: todayWater },\n    week: { ...weekCnt, water_ml: weekWater, top: topType(weekCnt) },\n    recent,\n    updated_at: now\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 2040,
        "wires": [
            [
                "48b24095339e8f46"
            ]
        ]
    },
    {
        "id": "48b24095339e8f46",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/user/summary",
        "statusCode": "",
        "headers": {},
        "x": 960,
        "y": 2040,
        "wires": []
    },
    {
        "id": "fc7132a95c44fe84",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 7",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1620,
        "y": 1200,
        "wires": []
    },
    {
        "id": "ce111f86ccf22e93",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 8",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1300,
        "y": 1200,
        "wires": []
    },
    {
        "id": "4ec68c37f9405b30",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/user/brief",
        "url": "/api/user/brief",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 370,
        "y": 2120,
        "wires": [
            [
                "642ff654d947d271"
            ]
        ]
    },
    {
        "id": "a6d2592241f69718",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "",
        "statusCode": "",
        "headers": {},
        "x": 1550,
        "y": 2120,
        "wires": []
    },
    {
        "id": "642ff654d947d271",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "BRIEF: build + firestore aggregate",
        "func": "// BRIEF: build + firestore aggregate\n// - Outputs: 2\n//   (1) OpenAI í˜¸ì¶œë¡œ ë³´ë‚¼ msg\n//   (2) ìºì‹œ íˆíŠ¸ ì‹œ ì¦‰ì‹œ HTTP Responseë¡œ ë³´ë‚¼ msg\n\nconst db = global.get(\"db\");\nlet GMS_KEY =\n  global.get(\"GMS_KEY\") ||\n  global.get(\"OPENAI_API_KEY\") ||\n  global.get(\"OPENAI_KEY\") ||\n  ((typeof env !== \"undefined\" && env.get) ? env.get(\"GMS_KEY\") : null);\n\nif (typeof GMS_KEY === \"string\" && GMS_KEY.startsWith(\"Bearer \")) {\n  GMS_KEY = GMS_KEY.slice(\"Bearer \".length);\n}\n\n\nfunction toMs(v) {\n  if (!v) return 0;\n  if (typeof v === \"number\") return v;\n  if (typeof v === \"string\") {\n    const n = Number(v);\n    if (Number.isFinite(n)) return n;\n    const d = Date.parse(v);\n    return Number.isFinite(d) ? d : 0;\n  }\n  if (typeof v === \"object\") {\n    if (typeof v.toMillis === \"function\") return v.toMillis();       // Firestore Timestamp\n    if (typeof v.seconds === \"number\") return v.seconds * 1000;       // {seconds, nanoseconds}\n  }\n  return 0;\n}\n\nfunction startOfTodayMs() {\n  const d = new Date();\n  d.setHours(0, 0, 0, 0);\n  return d.getTime();\n}\n\nfunction startOfThisWeekMsMonday() {\n  // ì›”ìš”ì¼ 00:00 ì‹œì‘(ë¡œì»¬)\n  const d = new Date();\n  const day = d.getDay(); // 0=ì¼ ... 1=ì›” ... 6=í† \n  const diffToMon = (day + 6) % 7; // ì›”=0, í™”=1 ... ì¼=6\n  d.setDate(d.getDate() - diffToMon);\n  d.setHours(0, 0, 0, 0);\n  return d.getTime();\n}\n\nfunction dayLabelMon0(idx) {\n  // chartLabelê³¼ ë§ì¶”ëŠ” ëŠë‚Œ(ì›”~ì¼)\n  const arr = [\"ì›”\", \"í™”\", \"ìˆ˜\", \"ëª©\", \"ê¸ˆ\", \"í† \", \"ì¼\"];\n  return arr[idx] || String(idx);\n}\n\nreturn (async () => {\n  if (!db) {\n    const out = {\n      statusCode: 500,\n      payload: { message: \"Firestore not initialized (global.db is missing)\" },\n    };\n    out.req = msg.req;\n    out.res = msg.res;\n    return [null, out];\n  }\n  if (!GMS_KEY) {\n    const out = {\n      statusCode: 503,\n      payload: { message: \"GMS_KEY is missing\" },\n    };\n    out.req = msg.req;\n    out.res = msg.res;\n    return [null, out];\n  }\n\n  const q = msg.req?.query || {};\n  const range = String(q.range || \"day\").toLowerCase() === \"week\" ? \"week\" : \"day\";\n  const refresh = String(q.refresh || \"0\") === \"1\";\n\n  // ----- ì„œë²„ ìºì‹œ -----\n  const now = Date.now();\n  const ttlMs = range === \"week\" ? 60 * 60 * 1000 : 10 * 60 * 1000; // week=1h, day=10m\n  const cache = global.get(\"briefCache\") || {};\n  const hit = cache[range];\n\n  if (!refresh && hit?.brief && hit?.ts && (now - hit.ts) < ttlMs) {\n    const out = {\n      statusCode: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n      payload: {\n        range,\n        cached: true,\n        generated_at: hit.ts,\n        brief: hit.brief,\n        stats: hit.stats || null,\n        ttl_ms: ttlMs,\n      },\n    };\n    out.req = msg.req;\n    out.res = msg.res;\n    return [null, out];\n  }\n\n  // ----- ê¸°ê°„ ê³„ì‚° -----\n  const sinceMs = (range === \"week\") ? startOfThisWeekMsMonday() : startOfTodayMs();\n  const rangeName = (range === \"week\") ? \"ì´ë²ˆ ì£¼\" : \"ì˜¤ëŠ˜\";\n\n  // ----- Firestoreì—ì„œ ìµœê·¼ Nê°œ ê°€ì ¸ì™€ì„œ ê¸°ê°„ í•„í„° -----\n  // (ì¸ë±ìŠ¤ ìµœì†Œí™”ìš©: created_at desc limit)\n  let docs = [];\n  try {\n    const snap = await db.collection(\"tasks\")\n      .orderBy(\"created_at\", \"desc\")\n      .limit(600)\n      .get();\n    docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));\n  } catch (e) {\n    const out = {\n      statusCode: 500,\n      payload: { message: \"Firestore query failed\", error: String(e?.message || e) },\n    };\n    out.req = msg.req;\n    out.res = msg.res;\n    return [null, out];\n  }\n\n  const tasks = docs\n    .map(t => {\n      const created = toMs(t.created_at);\n      const started = toMs(t.started_at);\n      const finished = toMs(t.finished_at);\n\n      // duration ê³„ì‚°(ì—†ìœ¼ë©´ 0)\n      let duration_s = 0;\n      if (started && finished && finished >= started) duration_s = Math.round((finished - started) / 1000);\n      else if (t.duration_s) duration_s = Number(t.duration_s) || 0;\n\n      return {\n        ...t,\n        _created_ms: created,\n        _duration_s: duration_s,\n        _status: String(t.status || \"\").toLowerCase(),\n        _type: String(t.type || \"\"),\n      };\n    })\n    .filter(t => t._created_ms >= sinceMs);\n\n  const total = tasks.length;\n  const doneTasks = tasks.filter(t => t._status === \"done\");\n  const done = doneTasks.length;\n\n  // íƒ€ì…ë³„\n  const countByType = {};\n  for (const t of tasks) {\n    countByType[t._type] = (countByType[t._type] || 0) + 1;\n  }\n\n  // ë¬¼/ì •ë¦¬ ì§€í‘œ(ë„ˆ í”„ë¡œì íŠ¸ ê¸°ì¤€)\n  const waterCount = countByType[\"deliver_water\"] || 0;\n  const laundryCount = countByType[\"collect_laundry\"] || 0;\n  const cupCount = countByType[\"collect_cup\"] || 0;\n\n  const waterCupMl = 250;\n  const waterMl = waterCount * waterCupMl;\n\n  // í‰ê·  ì†Œìš”\n  const durations = doneTasks.map(t => t._duration_s).filter(n => Number.isFinite(n) && n > 0);\n  const avgDurationS = durations.length ? Math.round(durations.reduce((a,b)=>a+b,0) / durations.length) : 0;\n\n  // íŒ¨í„´(í”¼í¬)\n  let peakText = \"ë°ì´í„°ê°€ ì•„ì§ ì ì–´ì„œ íŒ¨í„´ì„ ë³´ê¸° ì–´ë ¤ì›Œìš”.\";\n  if (total > 0) {\n    if (range === \"day\") {\n      const buckets = Array(24).fill(0);\n      for (const t of tasks) {\n        const h = new Date(t._created_ms).getHours();\n        buckets[h]++;\n      }\n      const mx = Math.max(...buckets);\n      const idx = buckets.indexOf(mx);\n      if (mx > 0) peakText = `${idx}ì‹œëŒ€ì— ìš”ì²­ì´ ê°€ì¥ ëª°ë ¸ì–´ìš”.`;\n    } else {\n      const buckets = Array(7).fill(0); // ì›”=0~ì¼=6\n      for (const t of tasks) {\n        const d = new Date(t._created_ms).getDay(); // 0=ì¼..6=í† \n        const mon0 = (d + 6) % 7;\n        buckets[mon0]++;\n      }\n      const mx = Math.max(...buckets);\n      const idx = buckets.indexOf(mx);\n      if (mx > 0) peakText = `${dayLabelMon0(idx)}ìš”ì¼ì— ìš”ì²­ì´ ê°€ì¥ ë§ì•˜ì–´ìš”.`;\n    }\n  }\n\n  // ìµœê·¼ 3ê°œ(ê¸°ê°„ ë‚´)\n  const recent3 = tasks\n    .slice()\n    .sort((a,b) => b._created_ms - a._created_ms)\n    .slice(0, 3)\n    .map(t => ({\n      type: t._type,\n      status: t._status,\n      area: t.target_area || null,\n      created_at: t._created_ms,\n      duration_s: t._duration_s,\n    }));\n\n  const pct = total ? Math.round((done / total) * 100) : 0;\n\n  const stats = {\n    range,\n    since_ms: sinceMs,\n    total,\n    done,\n    done_pct: pct,\n    avg_duration_s: avgDurationS,\n    by_type: countByType,\n    water_count: waterCount,\n    water_ml: waterMl,\n    laundry_count: laundryCount,\n    cup_count: cupCount,\n    peak: peakText,\n    recent3,\n  };\n\n  // ----- LLM í”„ë¡¬í”„íŠ¸(ì‚¬ìš©ì ì¹œí™” + ê°€ì¹˜ ì¤‘ì‹¬, ìš´ì˜ì í†¤ ê¸ˆì§€) -----\n  const prompt = `\në„ˆëŠ” ì‚¬ìš©ìë¥¼ ìœ„í•œ \"ì§§ê³  ìœ ìš©í•œ ìƒí™œ ë¸Œë¦¬í•‘\"ì„ ì‘ì„±í•œë‹¤.\nìš´ì˜ì/ê´€ë¦¬ì ê´€ì (ìš”ì²­ ì²˜ë¦¬, ì™„ë£Œ ë³´ê³ ì„œ í†¤) ê¸ˆì§€. ì‚¬ìš©ìê°€ ì–»ëŠ” ê°€ì¹˜(ìŠµê´€/ì»¨ë””ì…˜/ìƒí™œ ë¦¬ë“¬)ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë§í•´ë¼.\nì˜í•™ì  ì¡°ì–¸/ì§„ë‹¨ ê¸ˆì§€(ê°€ë³ê²Œ ê¶Œì¥ë§Œ).\n\n[ê¸°ê°„] ${rangeName}\n[ì§‘ê³„]\n- ì´ ìš”ì²­: ${total}ê±´, ì™„ë£Œ: ${done}ê±´(ì™„ë£Œìœ¨ ${pct}%)\n- í‰ê·  ì†Œìš”(ì™„ë£Œê±´): ${avgDurationS}s\n- ë¬¼ ë°°ë‹¬: ${waterCount}íšŒ (ì¶”ì • ì„­ì·¨ ${waterMl}ml, 1íšŒ=${waterCupMl}ml ê°€ì •)\n- í™˜ê²½ ì •ë¦¬(collect_laundry): ${laundryCount}íšŒ\n- ì»µ ìˆ˜ê±°(collect_cup): ${cupCount}íšŒ\n- íŒ¨í„´: ${peakText}\n- ìµœê·¼ ìš”ì²­ 3ê°œ: ${JSON.stringify(recent3)}\n\n[ì¶œë ¥ í˜•ì‹] ì•„ë˜ 5ì¤„ì„ ì •í™•íˆ ì§€ì¼œë¼(ê° ì¤„ì€ ì´ëª¨ì§€ë¡œ ì‹œì‘)\nğŸ§¾ í•œì¤„ìš”ì•½: ...\nğŸ’§ ë¬¼/ì»¨ë””ì…˜: ...\nğŸ§¹ ì •ë¦¬/ìƒí™œ: ...\nâ±ï¸ íŒ¨í„´: ...\nâœ… ì˜¤ëŠ˜(ë˜ëŠ” ì´ë²ˆ ì£¼) ì¶”ì²œ 1ê°€ì§€: ...\n`.trim();\n\n  const body = {\n    model: \"gpt-4.1-nano\",\n    max_completion_tokens: 220,\n    messages: [\n      { role: \"developer\", content: \"Answer in Korean.\" },\n      { role: \"user\", content: prompt },\n    ],\n  };\n\n  msg.headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Bearer ${GMS_KEY}`,\n  };\n  msg.payload = JSON.stringify(body);\n\n  // parse ë…¸ë“œì—ì„œ ìºì‹œ ì €ì¥ìš©ìœ¼ë¡œ ë„˜ê¹€\n  msg._brief_meta = { range, ttlMs, stats };\n\n  return [msg, null];\n})().catch((e) => {\n  const out = {\n    statusCode: 500,\n    payload: { message: \"BRIEF build failed\", error: String(e?.message || e) },\n  };\n  out.req = msg.req;\n  out.res = msg.res;\n  return [null, out];\n});",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 2120,
        "wires": [
            [
                "5290db53cf0d5b80"
            ],
            [
                "a6d2592241f69718"
            ]
        ]
    },
    {
        "id": "5290db53cf0d5b80",
        "type": "http request",
        "z": "49f8711fc297a8c1",
        "name": "",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://gms.ssafy.io/gmsapi/api.openai.com/v1/chat/completions",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1010,
        "y": 2120,
        "wires": [
            [
                "0199749053698397",
                "e003202d2963564d"
            ]
        ]
    },
    {
        "id": "0199749053698397",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "BRIEF: parse + respond",
        "func": "// // BRIEF: parse + respond\n// // - OpenAI ì‘ë‹µ íŒŒì‹±\n// // - ì„œë²„ ìºì‹œ ì €ì¥(global.briefCache)\n// // - ìµœì¢… HTTP Response payload ìƒì„±\n\n// const meta = msg._brief_meta || {};\n// const range = meta.range || \"day\";\n// const ttlMs = meta.ttlMs || 0;\n// const stats = meta.stats || null;\n\n// function fallbackBrief() {\n//   const rangeName = range === \"week\" ? \"ì´ë²ˆ ì£¼\" : \"ì˜¤ëŠ˜\";\n//   const total = stats?.total ?? 0;\n//   const done = stats?.done ?? 0;\n//   const pct = stats?.done_pct ?? 0;\n//   const waterMl = stats?.water_ml ?? 0;\n//   const waterCount = stats?.water_count ?? 0;\n//   const laundryCount = stats?.laundry_count ?? 0;\n//   const peak = stats?.peak || \"ì•„ì§ íŒ¨í„´ì„ ë³´ê¸°ì—” ë°ì´í„°ê°€ ë¶€ì¡±í•´ìš”.\";\n\n//   return [\n//     `ğŸ§¾ í•œì¤„ìš”ì•½: ${rangeName}ì—” ${total}ë²ˆ ë„ì›€ì„ ìš”ì²­í–ˆê³ , ${done}ë²ˆ ì²˜ë¦¬ëì–´ìš”(ì™„ë£Œìœ¨ ${pct}%).`,\n//     `ğŸ’§ ë¬¼/ì»¨ë””ì…˜: ë¬¼ ë°°ë‹¬ ${waterCount}íšŒ â†’ ëŒ€ëµ ${waterMl}ml ë§ˆì‹  ì…ˆì´ì—ìš”.`,\n//     `ğŸ§¹ ì •ë¦¬/ìƒí™œ: í™˜ê²½ ì •ë¦¬ ${laundryCount}íšŒë¡œ ìƒí™œ ê³µê°„ì„ ì˜ ìœ ì§€í–ˆì–´ìš”.`,\n//     `â±ï¸ íŒ¨í„´: ${peak}`,\n//     `âœ… ${rangeName} ì¶”ì²œ 1ê°€ì§€: ë¬¼ í•œ ë²ˆ ë” ì±™ê¸°ê±°ë‚˜, ìì£¼ ì“°ëŠ” êµ¬ì—­ ì •ë¦¬ë¥¼ ë£¨í‹´ìœ¼ë¡œ ê³ ì •í•´ë´ìš”.`,\n//   ].join(\"\\n\");\n// }\n\n// let brief = \"\";\n// try {\n//   const data = (typeof msg.payload === \"string\") ? JSON.parse(msg.payload) : msg.payload;\n//   brief = String(data?.choices?.[0]?.message?.content || \"\").trim();\n// } catch {\n//   brief = \"\";\n// }\n\n// if (!brief) brief = fallbackBrief();\n\n// // ---- ì„œë²„ ìºì‹œ ì €ì¥ ----\n// try {\n//   const cache = global.get(\"briefCache\") || {};\n//   cache[range] = { ts: Date.now(), brief, stats };\n//   global.set(\"briefCache\", cache);\n// } catch {}\n\n// // ---- response ----\n// msg.statusCode = 200;\n// msg.headers = { \"Content-Type\": \"application/json\" };\n// msg.payload = {\n//   range,\n//   cached: false,\n//   generated_at: Date.now(),\n//   ttl_ms: ttlMs,\n//   brief,\n//   stats,\n// };\n\n// return msg;\n// BRIEF: parse + respond\n// - OpenAI ì‘ë‹µ íŒŒì‹±\n// - ì„œë²„ ìºì‹œ ì €ì¥(global.briefCache)\n// - ìµœì¢… HTTP Response payload ìƒì„±\n\nconst meta = msg._brief_meta || {};\nconst range = meta.range || \"day\";\nconst ttlMs = meta.ttlMs || 0;\nconst stats = meta.stats || null;\n\nfunction fallbackBrief() {\n  const rangeName = range === \"week\" ? \"ì´ë²ˆ ì£¼\" : \"ì˜¤ëŠ˜\";\n  const total = stats?.total ?? 0;\n  const done = stats?.done ?? 0;\n  const pct = stats?.done_pct ?? 0;\n  const waterMl = stats?.water_ml ?? 0;\n  const waterCount = stats?.water_count ?? 0;\n  const laundryCount = stats?.laundry_count ?? 0;\n  const peak = stats?.peak || \"ì•„ì§ íŒ¨í„´ì„ ë³´ê¸°ì—” ë°ì´í„°ê°€ ë¶€ì¡±í•´ìš”.\";\n\n  return [\n    `ğŸ§¾ í•œì¤„ìš”ì•½: ${rangeName}ì—” ${total}ë²ˆ ë„ì›€ì„ ìš”ì²­í–ˆê³ , ${done}ë²ˆ ì²˜ë¦¬ëì–´ìš”(ì™„ë£Œìœ¨ ${pct}%).`,\n    `ğŸ’§ ë¬¼/ì»¨ë””ì…˜: ë¬¼ ë°°ë‹¬ ${waterCount}íšŒ â†’ ëŒ€ëµ ${waterMl}ml ë§ˆì‹  ì…ˆì´ì—ìš”.`,\n    `ğŸ§¹ ì •ë¦¬/ìƒí™œ: í™˜ê²½ ì •ë¦¬ ${laundryCount}íšŒë¡œ ìƒí™œ ê³µê°„ì„ ì˜ ìœ ì§€í–ˆì–´ìš”.`,\n    `â±ï¸ íŒ¨í„´: ${peak}`,\n    `âœ… ${rangeName} ì¶”ì²œ 1ê°€ì§€: ë¬¼ í•œ ë²ˆ ë” ì±™ê¸°ê±°ë‚˜, ìì£¼ ì“°ëŠ” êµ¬ì—­ ì •ë¦¬ë¥¼ ë£¨í‹´ìœ¼ë¡œ ê³ ì •í•´ë´ìš”.`,\n  ].join(\"\\n\");\n}\n\n// âœ… ì—¬ê¸° ì¶”ê°€: ì´ëª¨ì§€(ğŸ§¾ğŸ’§ğŸ§¹â±ï¸âœ…)ê°€ ë‚˜ì˜¤ë©´ ë¬´ì¡°ê±´ \"ì¤„ ì‹œì‘\"ìœ¼ë¡œ ì •ë ¬\nfunction normalizeBrief(raw) {\n  if (!raw) return \"\";\n\n  let s = String(raw)\n    .replace(/\\r\\n/g, \"\\n\")\n    .replace(/\\r/g, \"\\n\")\n    .trim();\n\n  // ì´ëª¨ì§€ ë§ˆì»¤(â±ï¸ëŠ” ë³€í˜•(â±)ë„ ì¡ì•„ì¤Œ)\n  // ë§ˆì»¤ ì•ì— ë¬´ì¡°ê±´ ê°œí–‰ì„ ë„£ê³ , ì¤‘ë³µ ê°œí–‰ì€ í•˜ë‚˜ë¡œ ì •ë¦¬\n  s = s.replace(/(ğŸ§¾|ğŸ’§|ğŸ§¹|â±ï¸|â±|âœ…)/g, \"\\n$1\");\n\n  // ì•ìª½ ë¶ˆí•„ìš” ê°œí–‰ ì œê±° + ê³µë°± ì •ë¦¬\n  s = s.replace(/^\\n+/, \"\");\n  s = s.replace(/\\n[ \\t]+/g, \"\\n\");\n  s = s.replace(/[ \\t]+\\n/g, \"\\n\");\n\n  // ê°œí–‰ì´ ì—¬ëŸ¬ ê°œ ìƒê¸°ë©´ 1ê°œë¡œ\n  s = s.replace(/\\n{2,}/g, \"\\n\").trim();\n\n  return s;\n}\n\nlet brief = \"\";\ntry {\n  const data = (typeof msg.payload === \"string\") ? JSON.parse(msg.payload) : msg.payload;\n  brief = String(data?.choices?.[0]?.message?.content || \"\").trim();\n} catch {\n  brief = \"\";\n}\n\nif (!brief) brief = fallbackBrief();\n\n// âœ… ê°•ì œ ì •ë ¬\nbrief = normalizeBrief(brief);\n\n// ---- ì„œë²„ ìºì‹œ ì €ì¥ ----\ntry {\n  const cache = global.get(\"briefCache\") || {};\n  cache[range] = { ts: Date.now(), brief, stats };\n  global.set(\"briefCache\", cache);\n} catch {}\n\n// ---- response ----\nmsg.statusCode = 200;\nmsg.headers = { \"Content-Type\": \"application/json\" };\nmsg.payload = {\n  range,\n  cached: false,\n  generated_at: Date.now(),\n  ttl_ms: ttlMs,\n  brief,\n  stats,\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 2120,
        "wires": [
            [
                "a6d2592241f69718"
            ]
        ]
    },
    {
        "id": "e003202d2963564d",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 9",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 2180,
        "wires": []
    },
    {
        "id": "196ad6fd54f9c6b6",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/app/settings",
        "url": "/api/app/settings",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 380,
        "y": 2240,
        "wires": [
            [
                "9e4d823bea057f41"
            ]
        ]
    },
    {
        "id": "9e4d823bea057f41",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/app/settings function",
        "func": "// // GET /api/app/settings\n// // Firestore ì „ì—­ ì„¤ì • ë¬¸ì„œì—ì„œ ê°€ì ¸ì˜¤ê¸°\n\n// const db =\n//   global.get(\"db\") ||\n//   global.get(\"firestore\") ||\n//   global.get(\"fsdb\");\n\n// if (!db) {\n//   msg.statusCode = 500;\n//   msg.payload = { ok: false, error: \"Firestore db not found in global context\" };\n//   return msg;\n// }\n\n// return (async () => {\n//   const ref = db.collection(\"app_config\").doc(\"global\"); // âœ… ì „ì—­ 1ë¬¸ì„œ\n//   const snap = await ref.get();\n\n//   msg.statusCode = 200;\n//   global.set(\"appSettings\", settings);\n//   msg.payload = { ok: true, settings: snap.exists ? snap.data() : null };\n//   return msg;\n// })().catch((e) => {\n//   msg.statusCode = 500;\n//   msg.payload = { ok: false, error: String(e) };\n//   return msg;\n// });\n\n// GET /api/app/settings function\nconst db = global.get(\"db\") || global.get(\"firestore\") || global.get(\"fsdb\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.payload = { ok: false, error: \"Firestore not ready\" };\n  return msg;\n}\n\nreturn (async () => {\n  const snap = await db.collection(\"app_config\").doc(\"global\").get();\n  const data = snap.exists ? (snap.data() || {}) : null;\n\n  // âœ… ì „ì—­ ìºì‹œ (undefined ë³€ìˆ˜ ì“°ì§€ ë§ ê²ƒ)\n  global.set(\"appSettings\", data || null);\n\n  msg.statusCode = 200;\n  msg.payload = { ok: true, settings: data || null };\n  return msg;\n})().catch((err) => {\n  node.error(err);\n  msg.statusCode = 500;\n  msg.payload = { ok: false, error: String(err?.message || err) };\n  return msg;\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 2240,
        "wires": [
            [
                "92e58e87bb22bc94"
            ]
        ]
    },
    {
        "id": "92e58e87bb22bc94",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/app/settings",
        "statusCode": "",
        "headers": {},
        "x": 960,
        "y": 2240,
        "wires": []
    },
    {
        "id": "cd4ac22d736413b0",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "POST /api/app/settings",
        "url": "/api/app/settings",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 380,
        "y": 2340,
        "wires": [
            [
                "3afe60812ab7ff80"
            ]
        ]
    },
    {
        "id": "3afe60812ab7ff80",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "POST /api/app/settings function",
        "func": "// // POST /api/app/settings\n// // body: { settings: {...} }\n\n// const db =\n//   global.get(\"db\") ||\n//   global.get(\"firestore\") ||\n//   global.get(\"fsdb\");\n\n// if (!db) {\n//   msg.statusCode = 500;\n//   msg.payload = { ok: false, error: \"Firestore db not found in global context\" };\n//   return msg;\n// }\n\n// const settings = msg.payload?.settings;\n// if (!settings || typeof settings !== \"object\") {\n//   msg.statusCode = 400;\n//   msg.payload = { ok: false, error: \"settings object required\" };\n//   return msg;\n// }\n\n// // âœ… í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ë¡œ ì•ˆì „í•˜ê²Œ ì €ì¥(ì›í•˜ëŠ” ê²ƒë§Œ)\n// const clean = {\n//   user_place: String(settings.user_place || \"RES_A\"),\n//   water_goal_ml: Number(settings.water_goal_ml || 0) || 0,\n//   routines: Array.isArray(settings.routines) ? settings.routines : [],\n//   updated_at: Date.now(),\n// };\n\n// return (async () => {\n//   await db.collection(\"app_config\").doc(\"global\").set(clean, { merge: true });\n//   global.set(\"appSettings\", setData);\n//   msg.statusCode = 200;\n//   msg.payload = { ok: true };\n//   return msg;\n// })().catch((e) => {\n//   msg.statusCode = 500;\n//   msg.payload = { ok: false, error: String(e) };\n//   return msg;\n// });\n\n\n// POST /api/app/settings function\nconst db = global.get(\"db\") || global.get(\"firestore\") || global.get(\"fsdb\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.payload = { ok: false, error: \"Firestore not ready\" };\n  return msg;\n}\n\n// body íŒŒì‹± (string/json ëª¨ë‘ ëŒ€ì‘)\nlet body = msg.payload;\nif (typeof body === \"string\") {\n  try { body = JSON.parse(body); } catch (e) { }\n}\n\nconst settingsIn = body?.settings;\nif (!settingsIn || typeof settingsIn !== \"object\") {\n  msg.statusCode = 400;\n  msg.payload = { ok: false, error: \"Invalid body: { settings: {...} } required\" };\n  return msg;\n}\n\n// ë£¨í‹´ sanitize\nfunction normTimeHHMM(t) {\n  if (!t) return \"00:00\";\n  const s = String(t).trim();\n  // \"HH:MM\"\n  if (/^\\d{2}:\\d{2}$/.test(s)) return s;\n  // \"H:MM\" -> \"0H:MM\"\n  if (/^\\d{1}:\\d{2}$/.test(s)) return \"0\" + s;\n  // \"HHMM\"\n  if (/^\\d{4}$/.test(s)) return s.slice(0, 2) + \":\" + s.slice(2);\n  return s.slice(0, 5);\n}\n\nfunction cleanRoutine(r) {\n  const rr = r && typeof r === \"object\" ? r : {};\n  return {\n    id: String(rr.id || `rt_${Date.now()}`),\n    enabled: rr.enabled !== false,\n    time: normTimeHHMM(rr.time),\n    repeat: rr.repeat === \"weekly\" ? \"weekly\" : \"daily\",\n    days: Array.isArray(rr.days) ? rr.days : [],\n    action_type: String(rr.action_type || rr.type || \"deliver_water\"),\n    target_mode: rr.target_mode === \"custom\" ? \"custom\" : \"my\",\n    target_area: String(rr.target_area || rr.area || \"\"),\n    created_at: Number(rr.created_at || Date.now()),\n  };\n}\n\nconst clean = {\n  // í•„ìš”í•œ ê²ƒë“¤ë§Œ í™•ì‹¤íˆ ë³´ì¡´\n  user_place: String(settingsIn.user_place || \"RES_A\"),\n  water_goal_ml: Number(settingsIn.water_goal_ml || 0) || 0,\n  routines: Array.isArray(settingsIn.routines) ? settingsIn.routines.map(cleanRoutine) : [],\n  updated_at: Date.now(),\n};\n\nreturn (async () => {\n  await db.collection(\"app_config\").doc(\"global\").set(clean, { merge: true });\n\n  // âœ… ì „ì—­ ìºì‹œ ì—…ë°ì´íŠ¸ (undefined setData ê¸ˆì§€)\n  global.set(\"appSettings\", clean);\n\n  msg.statusCode = 200;\n  msg.payload = { ok: true };\n  return msg;\n})().catch((err) => {\n  node.error(err);\n  msg.statusCode = 500;\n  msg.payload = { ok: false, error: String(err?.message || err) };\n  return msg;\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 2340,
        "wires": [
            [
                "a4f359686768196d"
            ]
        ]
    },
    {
        "id": "a4f359686768196d",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/app/settings",
        "statusCode": "",
        "headers": {},
        "x": 960,
        "y": 2340,
        "wires": []
    },
    {
        "id": "6f9693cf9fc68603",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "TICK (Routine Scheduler)",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 420,
        "y": 1360,
        "wires": [
            [
                "8808fa070f001f8e"
            ]
        ]
    },
    {
        "id": "8808fa070f001f8e",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "Routine Scheduler -> create msg.task",
        "func": "// /**\n//  * Routine Scheduler -> create msg.task\n//  * Fixes:\n//  * 1. KST Timezone ì ìš© (UTC+9)\n//  * 2. global.taskQueueì— push (ì‹¤ì œ ì‹¤í–‰ì„ ìœ„í•´)\n//  * 3. node.send() ë°©ì‹ ì‚¬ìš© (ì•ˆì •ì„±)\n//  */\n\n// function pad2(n) { return String(n).padStart(2, \"0\"); }\n\n// // KST ê¸°ì¤€ í˜„ì¬ ì‹œê°„ ê°ì²´ ë°˜í™˜\n// function getKSTDate() {\n//   const now = new Date();\n//   const utc = now.getTime() + (now.getTimezoneOffset() * 60000);\n//   const kstGap = 9 * 60 * 60 * 1000;\n//   return new Date(utc + kstGap);\n// }\n\n// function pickTimeStr(r) {\n//   const t = r.time ?? r.hhmm ?? r.at ?? r.run_at ?? r.when;\n//   if (!t) return null;\n//   if (typeof t === \"string\") {\n//     const s = t.trim();\n//     if (/^\\d{2}:\\d{2}$/.test(s)) return s;\n//     if (/^\\d{4}$/.test(s)) return s.slice(0, 2) + \":\" + s.slice(2, 4);\n//     return null;\n//   }\n//   if (typeof t === \"object\") {\n//     const hh = t.hh ?? t.hour;\n//     const mm = t.mm ?? t.minute;\n//     if (hh == null || mm == null) return null;\n//     return pad2(hh) + \":\" + pad2(mm);\n//   }\n//   return null;\n// }\n\n// function getIsoDow(jsDow) { return jsDow === 0 ? 7 : jsDow; } // Sun=0->7\n\n// function normalizeDays(days) {\n//   if (!Array.isArray(days) || days.length === 0) return null;\n//   const out = [];\n//   for (const d of days) {\n//     if (typeof d === \"number\" && Number.isFinite(d)) out.push(d);\n//     else if (typeof d === \"string\") {\n//       const s = d.trim().toLowerCase();\n//       const map = { sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6 };\n//       if (s in map) out.push(map[s]);\n//       else if (/^\\d+$/.test(s)) out.push(Number(s));\n//     }\n//   }\n//   return out.length ? out : null;\n// }\n\n// function matchDow(r, kstDate) {\n//   const jsDow = kstDate.getDay();      // 0(Sun)..6(Sat) (KST ê¸°ì¤€)\n//   const isoDow = getIsoDow(jsDow);     // 1(Mon)..7(Sun)\n\n//   const daysRaw = r.days ?? r.dow ?? r.daysOfWeek ?? r.weekdays;\n//   const days = normalizeDays(daysRaw);\n//   if (!days) return true; // ìš”ì¼ ì„¤ì • ì—†ìœ¼ë©´ ë§¤ì¼\n\n//   const has0 = days.includes(0);\n//   const has7 = days.includes(7);\n//   const looksIso = !has0 && (has7 || days.some(x => x >= 1 && x <= 7));\n\n//   if (looksIso) return days.includes(isoDow);\n//   return days.includes(jsDow);\n// }\n\n// function sanitizeId(s) {\n//   return String(s ?? \"\").trim().replace(/[^a-zA-Z0-9_-]/g, \"_\").slice(0, 60);\n// }\n\n// // ì˜ˆìƒ ì†Œìš”ì‹œê°„ ê¸°ë³¸ê°’\n// const baseMsMap = {\n//   water: 20000, drop: 15000, charge: 25000, wash: 20000, cancel: 3000, unknown: 20000\n// };\n\n// // ë©”ì¸ ë¡œì§ ì‹œì‘\n// (async () => {\n//   const db = global.get(\"db\") || global.get(\"fs\") || global.get(\"firestore\");\n//   if (!db) {\n//     node.status({ fill: \"red\", shape: \"ring\", text: \"Firestore not ready\" });\n//     // DB ì—†ìœ¼ë©´ ì¢…ë£Œ\n//     return;\n//   }\n\n//   // 1) routines ê°€ì ¸ì˜¤ê¸° (global cache ìš°ì„ )\n//   let settings = global.get(\"appSettings\");\n//   if (!settings) {\n//     try {\n//       const doc = await db.collection(\"app_config\").doc(\"global\").get();\n//       settings = doc.exists ? (doc.data() || {}) : {};\n//     } catch (e) {\n//       node.status({ fill: \"red\", shape: \"ring\", text: \"Read config failed\" });\n//       node.error(e);\n//       return;\n//     }\n//   }\n\n//   const routines = Array.isArray(settings.routines) ? settings.routines : [];\n//   if (!routines.length) {\n//     node.status({ fill: \"grey\", shape: \"ring\", text: \"No routines\" });\n//     return;\n//   }\n\n//   // 2) KST ì‹œê°„ ê³„ì‚° (UTC+9)\n//   const nowKST = getKSTDate();\n//   const hhmm = pad2(nowKST.getHours()) + \":\" + pad2(nowKST.getMinutes());\n//   const ymd = String(nowKST.getFullYear()) + pad2(nowKST.getMonth() + 1) + pad2(nowKST.getDate());\n//   const keyMinute = `${ymd}_${hhmm.replace(\":\", \"\")}`; // YYYYMMDD_HHMM\n\n//   let lastFired = context.get(\"lastFired\") || {};\n\n//   // ê¸€ë¡œë²Œ í ê°€ì ¸ì˜¤ê¸° (ì¤‘ìš”!)\n//   let queue = global.get('taskQueue') || [];\n//   let isQueueChanged = false;\n\n//   const outCreate = [];\n//   const outDbg = [];\n\n//   // í†µê³„ ë°ì´í„° (function2ì™€ ë™ì¼ ë¡œì§)\n//   const taskStats = global.get(\"taskStats\") || {};\n\n//   for (let i = 0; i < routines.length; i++) {\n//     const r = routines[i] || {};\n//     const enabled = (r.enabled ?? r.on ?? r.use ?? true) !== false;\n//     if (!enabled) continue;\n\n//     const t = pickTimeStr(r);\n//     if (!t || t !== hhmm) continue;     // ì‹œê°„ ì²´í¬ (KST ê¸°ì¤€)\n//     if (!matchDow(r, nowKST)) continue; // ìš”ì¼ ì²´í¬ (KST ê¸°ì¤€)\n\n//     const routineId = sanitizeId(r.id ?? r.routine_id ?? r.name ?? `idx${i}`);\n//     if (!routineId) continue;\n\n//     // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€\n//     if (lastFired[routineId] === keyMinute) continue;\n//     lastFired[routineId] = keyMinute;\n\n//     // Task ìƒì„±\n//     const typeRaw = (r.type ?? r.task_type ?? r.kind ?? \"water\");\n//     const type = String(typeRaw).trim().toLowerCase();\n//     const targetArea = String(r.target_area ?? r.area ?? r.target ?? \"WATER\").trim().toUpperCase();\n//     const priority = Number.isFinite(Number(r.priority)) ? Number(r.priority) : 50;\n\n//     const taskId = `task_rt_${routineId}_${keyMinute}`;\n//     const nowMs = Date.now(); // ìƒì„± ì‹œê°„ì€ timestamp(UTC) ê·¸ëŒ€ë¡œ ì¨ë„ ë¨ (í‘œì¤€)\n\n//     // ì˜ˆìƒ ì‹œê°„ ê³„ì‚° (EMA)\n//     const stat = taskStats[type];\n//     const expectedMs = (stat && stat.ema_ms) ? Math.round(stat.ema_ms) : (baseMsMap[type] || 20000);\n\n//     const task = {\n//       task_id: taskId,\n//       type,\n//       user_id: r.user_id ?? \"public\",\n//       status: \"pending\",\n//       created_at: nowMs,\n//       scheduled_at: nowMs,\n//       target_area: targetArea,\n//       priority,\n//       expected_duration_ms: expectedMs,\n//       eta_basis: (stat && stat.ema_ms) ? \"ema\" : \"default\",\n//       source: \"routine\",\n//       routine_id: routineId,\n//       params: r.params ?? {},\n//       interaction_id: null // ë£¨í‹´ì€ ì¸í„°ë™ì…˜ ì—†ìŒ\n//     };\n\n//     // 1. Outputìš© ë©”ì‹œì§€ ì¤€ë¹„\n//     outCreate.push({ task: task, payload: task });\n//     outDbg.push({ payload: { ok: true, created: true, hhmm, routineId, taskId } });\n\n//     // 2. Global Queueì— ì¶”ê°€ (ì¤‘ìš”!)\n//     queue.push(task);\n//     isQueueChanged = true;\n//   }\n\n//   // ìƒíƒœ ì €ì¥\n//   context.set(\"lastFired\", lastFired);\n//   if (isQueueChanged) {\n//     global.set('taskQueue', queue);\n//     // í•„ìš”í•˜ë‹¤ë©´ ì—¬ê¸°ì„œ í ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° ê°€ëŠ¥\n//   }\n\n//   if (!outCreate.length) {\n//     node.status({ fill: \"blue\", shape: \"dot\", text: `tick ${hhmm}` });\n//     return;\n//   }\n\n//   node.status({ fill: \"green\", shape: \"dot\", text: `created ${outCreate.length} @ ${hhmm}` });\n\n//   // ëª…ì‹œì ìœ¼ë¡œ ì „ì†¡\n//   node.send([outCreate, outDbg]);\n\n// })().catch(err => {\n//   node.error(err);\n//   node.status({ fill: \"red\", shape: \"dot\", text: \"Error\" });\n// });\n\n// Routine Scheduler -> create msg.task\n// output1: tasks to create (msg.task í¬í•¨)\n// output2: debug\n\nconst db = global.get(\"db\");\nif (!db) {\n  node.warn(\"Firestore not ready in Routine Scheduler\");\n  return [null, [{ payload: { ok: false, error: \"Firestore not ready\" } }]];\n}\n\n// ---- KST ê¸°ì¤€ ì‹œê°„(ì„œë²„ TZ ìƒê´€ì—†ì´) ----\nfunction pad2(n) { return String(n).padStart(2, \"0\"); }\nfunction nowKST() {\n  const k = new Date(Date.now() + 9 * 60 * 60 * 1000);\n  return {\n    y: k.getUTCFullYear(),\n    mo: k.getUTCMonth() + 1,\n    d: k.getUTCDate(),\n    hh: k.getUTCHours(),\n    mm: k.getUTCMinutes(),\n    isoDow: (() => { // 1=Mon ... 7=Sun\n      const js = k.getUTCDay(); // 0=Sun..6=Sat\n      return js === 0 ? 7 : js;\n    })(),\n  };\n}\n\nfunction normTimeHHMM(t) {\n  if (!t) return null;\n  const s = String(t).trim();\n  if (/^\\d{2}:\\d{2}$/.test(s)) return s;\n  if (/^\\d{1}:\\d{2}$/.test(s)) return \"0\" + s;\n  if (/^\\d{4}$/.test(s)) return s.slice(0, 2) + \":\" + s.slice(2);\n  return null;\n}\n\n// UserAppì˜ daysëŠ” \"ì›”=0..ì¼=6\" (mon0) í˜•íƒœë¡œ ë“¤ì–´ì˜¬ ìˆ˜ ìˆìŒ :contentReference[oaicite:6]{index=6}\n// â†’ ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ISO(1..7)ë¡œ ë°”ê¿”ì„œ ë¹„êµ\nfunction daysToIso(daysRaw) {\n  if (!Array.isArray(daysRaw) || daysRaw.length === 0) return null;\n\n  const mapStr = { mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6, sun: 7 };\n  const nums = [];\n\n  for (const x of daysRaw) {\n    if (typeof x === \"string\") {\n      const k = x.trim().toLowerCase();\n      if (mapStr[k]) nums.push(mapStr[k]);\n      continue;\n    }\n    if (Number.isFinite(x)) nums.push(Math.trunc(x));\n  }\n\n  if (nums.length === 0) return null;\n\n  // ì´ë¯¸ ISO(1..7)\n  if (nums.every(v => v >= 1 && v <= 7)) return Array.from(new Set(nums));\n\n  // mon0(0..6, Mon=0..Sun=6) â†’ ISO\n  if (nums.every(v => v >= 0 && v <= 6)) {\n    return Array.from(new Set(nums.map(v => (v === 6 ? 7 : v + 1))));\n  }\n\n  return null;\n}\n\nfunction normalizeType(raw) {\n  const s = String(raw || \"\").trim().toLowerCase();\n  if (!s) return \"deliver_water\";\n  const alias = {\n    water: \"deliver_water\",\n    cup: \"collect_cup\",\n    laundry: \"collect_laundry\",\n    charge: \"go_charge\",\n  };\n  return alias[s] || s;\n}\n\nfunction priorityOf(type) {\n  const p = {\n    deliver_water: 1,\n    collect_cup: 2,\n    collect_laundry: 3,\n    go_charge: 10,\n    cancel: 0,\n  };\n  return p[type] ?? 99;\n}\n\nconst k = nowKST();\nconst hhmmNow = `${pad2(k.hh)}:${pad2(k.mm)}`;\nconst keyMinute = `${k.y}${pad2(k.mo)}${pad2(k.d)}_${pad2(k.hh)}${pad2(k.mm)}`;\n\n// lastFired(ë¶„ ë‹¨ìœ„ ì¤‘ë³µ ë°©ì§€)\nlet lastFired = context.get(\"lastFired\") || {};\n// ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šê²Œ ì •ë¦¬\nconst keys = Object.keys(lastFired);\nif (keys.length > 5000) lastFired = {};\n\nlet outCreate = [];\nlet outDebug = [];\n\nreturn (async () => {\n  // settings: global cache ìš°ì„ , ì—†ìœ¼ë©´ Firestore\n  let settings = global.get(\"appSettings\");\n  if (!settings || typeof settings !== \"object\") {\n    const snap = await db.collection(\"app_config\").doc(\"global\").get();\n    settings = snap.exists ? (snap.data() || {}) : {};\n    global.set(\"appSettings\", settings);\n  }\n\n  const routines = Array.isArray(settings.routines) ? settings.routines : [];\n  if (routines.length === 0) return [null, null];\n\n  for (const r of routines) {\n    if (!r || r.enabled === false) continue;\n\n    const runAt = normTimeHHMM(r.time);\n    if (!runAt) continue;\n    if (runAt !== hhmmNow) continue;\n\n    // repeat/day ì²´í¬\n    const repeat = (r.repeat === \"weekly\") ? \"weekly\" : \"daily\";\n    if (repeat === \"weekly\") {\n      const isoDays = daysToIso(r.days);\n      if (isoDays && !isoDays.includes(k.isoDow)) continue;\n    }\n\n    const routineId = String(r.id || \"noid\");\n    const firedKey = `${routineId}:${keyMinute}`;\n    if (lastFired[firedKey]) continue;\n    lastFired[firedKey] = Date.now();\n\n    // âœ… action_type ìš°ì„  ì‚¬ìš© (UserAppì´ ì´ í•„ë“œë¡œ ì €ì¥í•¨) :contentReference[oaicite:7]{index=7}\n    const type = normalizeType(r.action_type ?? r.type ?? r.task_type ?? r.kind ?? \"deliver_water\");\n\n    const targetArea =\n      String(\n        r.target_area ||\n        r.area ||\n        (r.target_mode === \"my\" ? settings.user_place : \"\") ||\n        settings.user_place ||\n        \"USER1\"\n      ).trim();\n\n    const task = {\n      task_id: `task_rt_${routineId}_${keyMinute}`,\n      source: \"routine\",\n      routine_id: routineId,\n      type,\n      target_area: targetArea,\n      priority: priorityOf(type),\n      status: \"pending\",\n      scheduled_at: Date.now(),\n      created_at: Date.now(),\n      meta: {\n        repeat,\n        time: runAt,\n        days: Array.isArray(r.days) ? r.days : [],\n      },\n    };\n\n    outCreate.push({ task, payload: task });\n    outDebug.push({ payload: { ok: true, fired: firedKey, task_id: task.task_id, type, target_area: targetArea } });\n  }\n\n  context.set(\"lastFired\", lastFired);\n\n  return [\n    outCreate.length ? outCreate : null,\n    outDebug.length ? outDebug : null,\n  ];\n})().catch((err) => {\n  node.error(err);\n  return [null, [{ payload: { ok: false, error: String(err?.message || err) } }]];\n});\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 1360,
        "wires": [
            [
                "2ccacb1608c5ba74"
            ],
            [
                "1082c3d0195e3e5c"
            ]
        ]
    },
    {
        "id": "1082c3d0195e3e5c",
        "type": "debug",
        "z": "49f8711fc297a8c1",
        "name": "debug 10",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1180,
        "y": 1360,
        "wires": []
    },
    {
        "id": "630a23b48c76539c",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/interactions",
        "url": "/api/interactions",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 370,
        "y": 2440,
        "wires": [
            [
                "d9a029a8c294d68b"
            ]
        ]
    },
    {
        "id": "d9a029a8c294d68b",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "API: buildInteractionsResponse",
        "func": "// API: buildInteractionsResponse\n// GET /api/interactions?limit=100&type=deliver_water&input_mode=voice&result=accepted&q=water\n\nconst db = global.get(\"db\");\nif (!db) {\n  msg.statusCode = 503;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = { error: \"firestore not ready (global.db missing)\" };\n  return msg;\n}\n\nconst q = msg.req?.query || {};\n\nlet limit = parseInt(q.limit ?? \"100\", 10);\nif (!Number.isFinite(limit)) limit = 100;\nlimit = Math.max(1, Math.min(limit, 500));\n\nconst typeFilter = (q.type || \"\").toString().trim();              // deliver_water / collect_cup ...\nconst modeFilter = (q.input_mode || \"\").toString().trim();        // voice / text / button\nconst resultFilter = (q.result || \"\").toString().trim();          // accepted / rejected / pending\nconst keyword = (q.q || \"\").toString().trim().toLowerCase();      // search in raw/type/area\n\n// limitì´ ì‘ì•„ë„ í•„í„°ë§í•˜ë©´ ì¤„ ìˆ˜ ìˆìœ¼ë‹ˆ ë„‰ë„‰íˆ ê°€ì ¸ì˜¤ê¸°\nconst fetchN = Math.min(800, Math.max(250, limit * 5));\n\nfunction normalize(it) {\n  const parsed = it?.parsed || null;\n\n  const type = it.type || parsed?.type || null;\n  const target_area =\n    it.target_area ||\n    parsed?.target_area ||\n    parsed?.area ||\n    null;\n\n  const raw_text =\n    it.raw_text ||\n    it.raw_input ||\n    it.raw ||\n    it.text ||\n    null;\n\n  const task_id =\n    it.task_id ||\n    it.interaction_id ||  // ë„ˆí¬ ì‹œìŠ¤í…œì€ task_id=interaction_id ì“°ëŠ” íë¦„ì´ ë§ì•„ì„œ ì•ˆì „ë¹µ\n    null;\n\n  return { ...it, type, target_area, raw_text, task_id };\n}\n\nfunction hitKeyword(it, kw) {\n  if (!kw) return true;\n  const a = (it.type || \"\").toString().toLowerCase();\n  const b = (it.target_area || \"\").toString().toLowerCase();\n  const c = (it.raw_text || \"\").toString().toLowerCase();\n  const d = (it.input_mode || \"\").toString().toLowerCase();\n  const e = (it.result || \"\").toString().toLowerCase();\n  return (\n    a.includes(kw) ||\n    b.includes(kw) ||\n    c.includes(kw) ||\n    d.includes(kw) ||\n    e.includes(kw)\n  );\n}\n\nreturn new Promise(async (resolve) => {\n  try {\n    const snap = await db\n      .collection(\"interactions\")\n      .orderBy(\"ts\", \"desc\")\n      .limit(fetchN)\n      .get();\n\n    let interactions = snap.docs.map((d) => normalize(d.data()));\n\n    if (typeFilter) interactions = interactions.filter((x) => (x.type || \"\") === typeFilter);\n    if (modeFilter) interactions = interactions.filter((x) => (x.input_mode || \"\") === modeFilter);\n    if (resultFilter) interactions = interactions.filter((x) => (x.result || \"\") === resultFilter);\n    if (keyword) interactions = interactions.filter((x) => hitKeyword(x, keyword));\n\n    interactions = interactions.slice(0, limit);\n\n    const stats = { total: interactions.length, by_type: {}, by_mode: {}, by_result: {} };\n    for (const it of interactions) {\n      const t = it.type || \"(none)\";\n      const m = it.input_mode || \"(none)\";\n      const r = it.result || \"(none)\";\n      stats.by_type[t] = (stats.by_type[t] || 0) + 1;\n      stats.by_mode[m] = (stats.by_mode[m] || 0) + 1;\n      stats.by_result[r] = (stats.by_result[r] || 0) + 1;\n    }\n\n    msg.statusCode = 200;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { interactions, stats };\n    resolve(msg);\n  } catch (err) {\n    node.error(err);\n    msg.statusCode = 500;\n    msg.headers = { \"Content-Type\": \"application/json\" };\n    msg.payload = { error: \"failed to fetch interactions\", detail: String(err?.message || err) };\n    resolve(msg);\n  }\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 2440,
        "wires": [
            [
                "e4dd7184fd5e416f"
            ]
        ]
    },
    {
        "id": "094bc8cffcab51de",
        "type": "http in",
        "z": "49f8711fc297a8c1",
        "name": "GET /api/interactions/insight",
        "url": "/api/interactions/insight",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 400,
        "y": 2520,
        "wires": [
            [
                "7c6537b8615fc6ba"
            ]
        ]
    },
    {
        "id": "7c6537b8615fc6ba",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "INSIGHT: build + aggregate (2 outputs)",
        "func": "// INSIGHT: build + aggregate (2 outputs)\n// out1: OpenAIë¡œ ë³´ë‚¼ ìš”ì²­ msg\n// out2: ìºì‹œ/ì—ëŸ¬ ì¦‰ì‹œ HTTP ì‘ë‹µ msg\n\nconst db = global.get(\"db\");\n\n// GMS_KEY ì½ê¸°(ë„ˆí¬ flow ìŠ¤íƒ€ì¼ ìµœëŒ€í•œ ë”°ë¼ê°)\nlet GMS_KEY =\n  global.get(\"GMS_KEY\") ||\n  global.get(\"OPENAI_API_KEY\") ||\n  global.get(\"OPENAI_KEY\") ||\n  ((typeof env !== \"undefined\" && env.get) ? env.get(\"GMS_KEY\") : null);\n\nif (typeof GMS_KEY === \"string\" && GMS_KEY.startsWith(\"Bearer \")) {\n  GMS_KEY = GMS_KEY.slice(\"Bearer \".length);\n}\n\nfunction httpOut(payload, statusCode = 200) {\n  return {\n    req: msg.req,\n    res: msg.res,\n    statusCode,\n    headers: { \"Content-Type\": \"application/json\" },\n    payload\n  };\n}\n\nif (!db) {\n  return [null, httpOut({ error: \"firestore not ready (global.db missing)\" }, 503)];\n}\nif (!GMS_KEY) {\n  return [null, httpOut({ error: \"GMS_KEY missing\" }, 503)];\n}\n\nconst q = msg.req?.query || {};\nconst range = (q.range || \"week\").toString();   // day | week\nconst refresh = (q.refresh === \"1\" || q.refresh === \"true\");\n\nconst ttlMs = 3 * 60 * 1000; // 3ë¶„ ìºì‹œ\nconst now = Date.now();\n\nconst cacheKey = \"interactionInsightCache\";\nconst cache = global.get(cacheKey) || {};\nconst cached = cache[range];\n\nif (!refresh && cached && (now - cached.generated_at) < ttlMs) {\n  return [null, httpOut({ ...cached, cached: true })];\n}\n\n// ê¸°ê°„ ì„¤ì •\nlet windowMs = 7 * 24 * 3600 * 1000; // week\nif (range === \"day\") windowMs = 24 * 3600 * 1000;\nconst fromTs = now - windowMs;\n\nfunction pickType(it) {\n  return it?.type || it?.parsed?.type || \"(none)\";\n}\nfunction pickArea(it) {\n  return it?.target_area || it?.parsed?.target_area || it?.parsed?.area || \"(none)\";\n}\nfunction pickRaw(it) {\n  return it?.raw_text || it?.raw_input || it?.raw || it?.text || \"\";\n}\nfunction pickTs(it) {\n  const t = it?.ts;\n  return (typeof t === \"number\") ? t : 0;\n}\n\nreturn (async () => {\n  try {\n    const snap = await db\n      .collection(\"interactions\")\n      .orderBy(\"ts\", \"desc\")\n      .limit(800)\n      .get();\n\n    let arr = snap.docs.map(d => d.data());\n    arr = arr.filter(x => pickTs(x) >= fromTs);\n\n    const stats = {\n      range,\n      from_ts: fromTs,\n      to_ts: now,\n      total: arr.length,\n      by_type: {},\n      by_mode: {},\n      by_result: {},\n      by_area: {},\n      accepted: 0,\n      rejected: 0,\n      pending: 0\n    };\n\n    const examples = [];\n\n    for (const it of arr) {\n      const type = pickType(it);\n      const mode = it?.input_mode || \"(none)\";\n      const result = it?.result || \"(none)\";\n      const area = pickArea(it);\n\n      stats.by_type[type] = (stats.by_type[type] || 0) + 1;\n      stats.by_mode[mode] = (stats.by_mode[mode] || 0) + 1;\n      stats.by_result[result] = (stats.by_result[result] || 0) + 1;\n      stats.by_area[area] = (stats.by_area[area] || 0) + 1;\n\n      if (result === \"accepted\") stats.accepted++;\n      else if (result === \"rejected\") stats.rejected++;\n      else if (result === \"pending\") stats.pending++;\n\n      if (examples.length < 18) {\n        examples.push({\n          ts: it.ts,\n          input_mode: it.input_mode,\n          type,\n          target_area: area,\n          result,\n          raw: pickRaw(it).slice(0, 90)\n        });\n      }\n    }\n\n    const acceptanceRate =\n      stats.total > 0 ? Math.round((stats.accepted / stats.total) * 100) : 0;\n\n    const promptData = {\n      range,\n      acceptance_rate_pct: acceptanceRate,\n      stats,\n      examples\n    };\n\n    // OpenAI ìš”ì²­ ë§Œë“¤ê¸°\n    msg.headers = {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": `Bearer ${GMS_KEY}`\n    };\n\n    msg.payload = {\n      model: \"gpt-5\",\n      messages: [\n        {\n          role: \"system\",\n          content:\n            \"ë„ˆëŠ” ë‹¨ì¼ ë¡œë´‡ AGV ì„œë¹„ìŠ¤ì˜ ìš´ì˜ ë¶„ì„ê°€ë‹¤. \" +\n            \"ìš´ì˜ì ëŒ€ì‹œë³´ë“œì—ì„œ ë°”ë¡œ í™œìš©í•  ìˆ˜ ìˆëŠ” ì¸ì‚¬ì´íŠ¸ë¥¼ 'í•œêµ­ì–´'ë¡œ, ê°„ê²°í•˜ê³  ì‹¤í–‰ ê°€ëŠ¥í•˜ê²Œ ì‘ì„±í•˜ë¼. \" +\n            \"ë¶ˆí•„ìš”í•œ ë¯¸ì‚¬ì—¬êµ¬ëŠ” ë¹¼ê³ , ìš´ì˜ ê´€ì (ë¹ˆë„/ì„±ê³µë¥ /ì‹¤íŒ¨ íŒ¨í„´/ì±„ë„ë³„ ê²½í–¥/ì¶”ì²œ ì•¡ì…˜)ì— ì§‘ì¤‘í•˜ë¼.\"\n        },\n        {\n          role: \"user\",\n          content:\n            \"ë°˜ë“œì‹œ JSONë§Œ ì¶œë ¥í•´. (ë§ˆí¬ë‹¤ìš´/ì½”ë“œë¸”ë¡/ì„¤ëª… ë¬¸ì¥ ê¸ˆì§€)\\n\" +\n            \"ìŠ¤í‚¤ë§ˆ: { summary: string, insights: string[], actions: string[] }\\n\" +\n            \"- summary: 2~3ë¬¸ì¥ ìš”ì•½ (í•œêµ­ì–´)\\n\" +\n            \"- insights: í•µì‹¬ ê´€ì°° 3~6ê°œ (í•œêµ­ì–´, ì§§ê²Œ)\\n\" +\n            \"- actions: ìš´ì˜ìê°€ ë°”ë¡œ í•  ìˆ˜ ìˆëŠ” ì¡°ì¹˜ 3~6ê°œ (í•œêµ­ì–´)\\n\" +\n            \"ë°ì´í„°: \" + JSON.stringify(promptData)\n        }\n      ]\n    };\n\n    msg._insight_meta = { range, ttlMs, stats };\n    return [msg, null];\n  } catch (e) {\n    node.error(e);\n    return [null, httpOut({ error: \"failed to build insight request\", detail: String(e?.message || e) }, 500)];\n  }\n})();\n\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 2520,
        "wires": [
            [
                "3e49308cd5aa3552"
            ],
            [
                "8cb359fd2ff33522"
            ]
        ]
    },
    {
        "id": "e4dd7184fd5e416f",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/interactions",
        "statusCode": "",
        "headers": {},
        "x": 970,
        "y": 2440,
        "wires": []
    },
    {
        "id": "3e49308cd5aa3552",
        "type": "http request",
        "z": "49f8711fc297a8c1",
        "name": "",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://gms.ssafy.io/gmsapi/api.openai.com/v1/chat/completions",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1070,
        "y": 2520,
        "wires": [
            [
                "3204e36a38371d1e"
            ]
        ]
    },
    {
        "id": "3204e36a38371d1e",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "INSIGHT: parse + respond",
        "func": "// INSIGHT: parse + respond\n// OpenAI ì‘ë‹µ -> JSON íŒŒì‹± -> ìºì‹œ ì €ì¥ -> HTTP ì‘ë‹µ\n\nconst meta = msg._insight_meta || {};\nconst range = meta.range || \"week\";\nconst ttlMs = meta.ttlMs || (3 * 60 * 1000);\nconst stats = meta.stats || null;\n\nfunction cleanJsonText(s) {\n  const t = (s || \"\").trim();\n  // ```json ... ``` ì œê±°\n  if (t.startsWith(\"```\")) {\n    return t.replace(/^```[a-zA-Z]*\\s*/,\"\").replace(/```$/,\"\").trim();\n  }\n  return t;\n}\n\ntry {\n  // http request ë…¸ë“œê°€ objë¡œ ë°›ìœ¼ë©´ msg.payloadì— choices ìˆìŒ\n  const contentRaw = msg.payload?.choices?.[0]?.message?.content || \"\";\n  const content = cleanJsonText(contentRaw);\n\n  let insight;\n  try {\n    insight = JSON.parse(content);\n  } catch {\n    // JSON ì‹¤íŒ¨í•˜ë©´ ê·¸ëƒ¥ í…ìŠ¤íŠ¸ë¥¼ summaryë¡œë¼ë„ ì‚´ë ¤ì¤Œ\n    insight = { summary: content || \"No content\", insights: [], actions: [] };\n  }\n\n  const out = {\n    range,\n    cached: false,\n    generated_at: Date.now(),\n    ttl_ms: ttlMs,\n    stats,\n    insight\n  };\n\n  // ìºì‹œ ì €ì¥\n  const cacheKey = \"interactionInsightCache\";\n  const cache = global.get(cacheKey) || {};\n  cache[range] = out;\n  global.set(cacheKey, cache);\n\n  msg.statusCode = 200;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = out;\n  return msg;\n\n} catch (e) {\n  node.error(e);\n  msg.statusCode = 500;\n  msg.headers = { \"Content-Type\": \"application/json\" };\n  msg.payload = { error: \"failed to parse insight\", detail: String(e?.message || e) };\n  return msg;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 2520,
        "wires": [
            [
                "8cb359fd2ff33522"
            ]
        ]
    },
    {
        "id": "8cb359fd2ff33522",
        "type": "http response",
        "z": "49f8711fc297a8c1",
        "name": "res /api/interactions/insight",
        "statusCode": "",
        "headers": {},
        "x": 1720,
        "y": 2520,
        "wires": []
    },
    {
        "id": "883a93ffa0dfc670",
        "type": "inject",
        "z": "49f8711fc297a8c1",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 3290,
        "y": 1260,
        "wires": [
            [
                "06eda9d982d873c9"
            ]
        ]
    },
    {
        "id": "06eda9d982d873c9",
        "type": "function",
        "z": "49f8711fc297a8c1",
        "name": "function 4",
        "func": "// âœ… HARD RESET (global + flow) + immediately verify\nfunction safeSetGlobal(key, val) {\n  global.set(key, val); // default store\n  try { global.set(key, val, \"file\"); } catch (e) {}\n  try { global.set(key, val, \"memory\"); } catch (e) {}\n}\n\nfunction safeSetFlow(key, val) {\n  flow.set(key, val); // default store\n  try { flow.set(key, val, \"file\"); } catch (e) {}\n  try { flow.set(key, val, \"memory\"); } catch (e) {}\n}\n\nsafeSetGlobal(\"taskQueue\", []);\nsafeSetGlobal(\"robots\", {});\nsafeSetGlobal(\"events\", []);\n\nsafeSetFlow(\"taskQueue\", []);\nsafeSetFlow(\"robots\", {});\nsafeSetFlow(\"events\", []);\n\nconst gq = global.get(\"taskQueue\");\nconst gr = global.get(\"robots\");\nconst ge = global.get(\"events\");\n\nnode.warn({\n  reset: \"OK\",\n  global: {\n    taskQueue_len: Array.isArray(gq) ? gq.length : \"not-array\",\n    robots_keys: gr ? Object.keys(gr).length : \"null\",\n    events_len: Array.isArray(ge) ? ge.length : \"not-array\",\n  }\n});\n\nmsg.payload = { ok: true, global: { taskQueue: gq, robots: gr, events: ge } };\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3500,
        "y": 1260,
        "wires": [
            []
        ]
    },
    {
        "id": "d10c4415b361b866",
        "type": "telegram bot",
        "botname": "yujinnnojin",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "pollinterval": 300,
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": 6667,
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbothost": "0.0.0.0",
        "localbotport": 8443,
        "publicbotport": 8443,
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "3c16a07776b27396",
        "type": "mqtt-broker",
        "name": "Server",
        "broker": "localhost",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e6e1b7942a2b8330",
        "type": "ui_group",
        "name": "Robots",
        "tab": "8949e4e33e605647",
        "order": 2,
        "disp": true,
        "width": 6,
        "collapse": false,
        "className": ""
    },
    {
        "id": "7e8e44e7110066b9",
        "type": "ui_group",
        "name": "Summary",
        "tab": "8949e4e33e605647",
        "order": 1,
        "disp": true,
        "width": 6,
        "collapse": false,
        "className": ""
    },
    {
        "id": "920df32220cd089d",
        "type": "ui_group",
        "name": "Tasks",
        "tab": "8949e4e33e605647",
        "order": 3,
        "disp": true,
        "width": 6,
        "collapse": false,
        "className": ""
    },
    {
        "id": "ab2f507577ca5dbe",
        "type": "ui_group",
        "name": "Events",
        "tab": "8949e4e33e605647",
        "order": 4,
        "disp": true,
        "width": 6,
        "collapse": false,
        "className": ""
    },
    {
        "id": "8949e4e33e605647",
        "type": "ui_tab",
        "name": "AGV Control Center",
        "icon": "dashboard",
        "order": 1,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "d9ad998a64d88300",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-telegrambot": "17.0.3",
            "node-red-dashboard": "3.6.6"
        }
    }
]